/*
 *  This file is part of OpenStaticAnalyzer.
 *
 *  Copyright (c) 2004-2018 Department of Software Engineering - University of Szeged
 *
 *  Licensed under Version 1.2 of the EUPL (the "Licence");
 *
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence in the LICENSE file or at:
 *
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the Licence for the specific language governing permissions and
 *  limitations under the Licence.
 */

#define PROGRAM_NAME "LIM2PatternsTool"
#define EXECUTABLE_NAME "LIM2Patterns"

#include "../inc/LIM2Patterns.h"
#include <cstdlib>
#include <MainCommon.h>
#include <pybind11/pybind11.h>
#include <rul/inc/RulHandler.h>
#include <rul/inc/RulMD.h>
#include <common/inc/WriteMessage.h>
#include <common/inc/FileSup.h>
#include <filesystem>
#include <boost/algorithm/string.hpp>
#include <common/inc/PlatformDependentDefines.h>

namespace py = pybind11;

using namespace std;
using namespace common;
using namespace columbus;

static vector<string> files;
static string patternFile;
static string patternsFolder;
static string outFile;
static string metricFile;
static string graphFile;
static string limFile;
static string whitelist = "";
static string blacklist = "";
static string rulDumpDir = "";
static bool dumpXML = false;

static void ppFile(char *filename) {
    files.push_back(filename);
}

static bool ppGetPattern(const Option *o, char *argv[]) {
    patternFile = argv[0];
    return true;
}

static bool ppOutputFileName(const Option *o, char *argv[]) {
    outFile = argv[0];
    return true;
}

static bool ppOutputFileNameDefault(const Option *o) {
    outFile = "";
    return true;
}

static bool ppMetricRulFileName(const Option *o, char *argv[]) {
    metricFile = argv[0];
    return true;
}

static bool ppDefaultMetricRulFileName(const Option *o) {
    metricFile = "";
    return true;
}

static bool ppGraphFile(const Option *o, char *argv[]) {
    graphFile = argv[0];
    return true;
}

static bool ppGraphFileDefault(const Option *o) {
    graphFile = "";
    return true;
}

static bool ppLimFile(const Option *o, char *argv[]) {
    limFile = argv[0];
    return true;
}

static bool ppLimFileDefault(const Option *o) {
    limFile = "";
    return true;
}

static bool ppWhitelist(const Option *o, char *argv[]) {
    whitelist = argv[0];
    return true;
}

static bool ppBlacklist(const Option *o, char *argv[]) {
    blacklist = argv[0];
    return true;
}

static bool ppDumpXML(const Option *o, char *argv[]) {
    dumpXML = true;
    return true;
}

static bool ppDumpPatternsRul(const Option *o, char *argv[]) {
    rulDumpDir = argv[0];
    return true;
}

static bool ppDumpPatternsRulDefault(const Option *o) {
    rulDumpDir = "";
    return true;
}

const Option OPTIONS_OBJ[] = {
    { false, "-out",            1, CL_KIND_FILENAME, 0, OT_WC, ppOutputFileName,      ppOutputFileNameDefault,     "Output file name."},
    { false, "-metrics",        1, CL_KIND_FILENAME, 3, OT_WC, ppMetricRulFileName,   ppDefaultMetricRulFileName,  "The MET.rul file."},
    { false, "-graph",          1, CL_KIND_FILENAME, 3, OT_WC, ppGraphFile,           ppGraphFileDefault,          "The Graph file generated by OpenStaticAnalyzer. Default graph is generated from the lim + metrics files"},
    { false, "-lim",            1, CL_KIND_FILENAME, 1, OT_WC, ppLimFile,             ppLimFileDefault,            "The LIM file generated by OpenStaticAnalyzer."},
    { false, "-whitelist",      1, CL_KIND_STRING,   0, OT_WC, ppWhitelist,           NULL,                        "The name of the pattern. By default, all the patterns will be tested. Works as a pattern whitelist."},
    { false, "-blacklist",      1, CL_KIND_STRING,   0, OT_WC, ppBlacklist,           NULL,                        "The name of the pattern. Works as a pattern blacklist."},
    { false, "-dumpXML",        0, "",               0, OT_WC, ppDumpXML,             NULL,                        "Dump the output graph. Default value is false."},
    { false, "-dumpPatternsRUL",1, CL_KIND_DIR,      0, OT_WC, ppDumpPatternsRul,     ppDumpPatternsRulDefault,    "Dump the patterns rul into Patterns.rul"},
    CL_LIM2PATTERNS
    COMMON_CL_ARGS
};

bool validExtension(const string&_patternFile) {
    using columbus::lim::patterns::validExtensions;

    string extension = common::pathFindExtension(_patternFile);
    if (!std::count(validExtensions.begin(), validExtensions.end(), extension)) {
        string correctExtensions = "";
        auto it = validExtensions.begin();
        while (it != validExtensions.end()) {
            correctExtensions += *it;
            it++;
            if (it != validExtensions.end()) {
                correctExtensions += ", ";
            }
        }
        return false;
    }
    return true;
}

int main(int argc, char** argv) {
    Py_NoSiteFlag = 1;
    Py_FrozenFlag = 1;
    Py_IgnoreEnvironmentFlag = 1;
    Py_IsolatedFlag = 1;

    string path_separator = PATH_SEPARATOR;
    wstring wpath_separator { path_separator.begin(), path_separator.end() };
    filesystem::path _exec_path = getExecutableProgramDir();
    std::wstring libs = (_exec_path / "python-modules").wstring() + wpath_separator + (_exec_path / "python-modules" / "lib-dynload").wstring();
    const wchar_t *_exec1 = Py_DecodeLocale(argv[0], NULL);

    Py_SetPath(libs.c_str());
    Py_SetProgramName(_exec1);
    PySys_AddWarnOption(L"ignore::DeprecationWarning");

    vector<string> patternFiles;
    std::unique_ptr<py::scoped_interpreter> guard;

    MAIN_BEGIN
    MainInit(argc, argv, "-");
    
    if (limFile.empty() || !common::pathFileExists(limFile, false)) {
        WriteMsg::write(CMSG_INVALID_LIM_FILE);
        clError();
    }

    if (graphFile.empty() && metricFile.empty()) {
        WriteMsg::write(CMSG_NO_GRAPH_AND_METRICS);
        clError();
    }

    if (!metricFile.empty() && !common::pathFileExists(metricFile, false)) {
        WriteMsg::write(CMSG_METRIC_RUL_INVALID);
        clError();
    }

    if (!patternFile.empty()) {
        using namespace std::filesystem;

        const auto &getPatterns = [&](const string &pattern) {
            path _pattern(pattern);

            if (!common::pathFileExists(pattern)) {
                WriteMsg::write(CMSG_PATTERN_IS_INVALID(pattern));
                clError();
            }
            // get all pattern file in the folder
            if (!_pattern.has_extension()) {
                for (auto &_entry : directory_iterator(_pattern)) {
                    path _path(_entry.path());
                    string _file = _path.string();

                    if (validExtension(_file)) {
                        patternFiles.push_back(_file);
                    }
                }
                if (patternFiles.empty()) {
                    WriteMsg::write(CMSG_PATTERN_FOLDER_EMPTY);
                    clError();
                }
            }
            else {
                patternFiles.push_back(_pattern.string());
            }
        };

        vector<string> res;
        boost::split(res, patternFile, boost::is_any_of(","));
        for (auto &s : res) {
            getPatterns(s);
        }

        sort(patternFiles.begin(), patternFiles.end());
    }
    else {
        WriteMsg::write(CMSG_INVALID_PATTERN_FILE);
        clError();
    }

    for (auto &_patternFile : patternFiles) {
        auto ext = common::pathFindExtension(_patternFile);
        if (ext == "py") {
            WriteMsg::write(common::WriteMsg::mlNormal, "Loading: Python-" + string(PY_VERSION) + " interpreter...\n");
            guard = make_unique<py::scoped_interpreter>(false);
            break;
        }
    }

    if (!graphFile.empty() && !common::pathFileExists(graphFile, false)) {
        WriteMsg::write(CMSG_INVALID_GRAPH_FILE);
        clError();
    }
    
    if (!rulDumpDir.empty() && !common::pathIsDirectory(rulDumpDir)) {
        WriteMsg::write(CMSG_INVALID_RULDIRECTORY);
        clError();
    }

    if (!outFile.empty()) {
        filesystem::path _out(outFile);
        auto temp = _out.filename();
        if (!temp.has_extension() && !common::pathIsDirectory(_out.string())) {
            WriteMsg::write(CMSG_INVALID_OUTPUT_FILE);
            clError();
        }
        else {
            if (common::pathIsDirectory(outFile)) {
                filesystem::path _out(outFile);
                _out /= (common::pathRemoveExtension(common::pathFindFileName(limFile)));
                outFile = _out.string();
            }
            else {
                outFile = common::pathRemoveExtension(outFile);
            }
        }
    }
    else {
        outFile = common::pathRemoveExtension(limFile);
    }

    std::set<std::string> _whitelist, _blacklist;
    const auto &vecToString = [](const vector<string> &s) {
        string r = "[";
        for (size_t i = 0; i < s.size(); i++) {
            r += " " + s[i];
            if (i + 1 != s.size()) {
                r += ",";
            }
            else {
                r += " ]";
            }
        }
        return r;
    };
    if (whitelist != "") {
        vector<string> res;
        boost::split(res, whitelist, boost::is_any_of(","));
        string log = "Whitelist detected: " + vecToString(res) + "\n";
        _whitelist.insert(res.begin(), res.end());
        WriteMsg::write(common::WriteMsg::mlNormal, log);
    }
    if (blacklist != "") {
        vector<string> res;
        boost::split(res, blacklist, boost::is_any_of(","));
        string log = "Blacklist detected: " + vecToString(res) + "\n";
        _blacklist.insert(res.begin(), res.end());
        WriteMsg::write(common::WriteMsg::mlNormal, log);
    }

    columbus::lim::patterns::lim2Patterns(limFile, patternFiles, _whitelist, _blacklist, outFile, patternsFolder, metricFile, graphFile, dumpXML, rulDumpDir);

    MAIN_END


    return 0;
}
