<?xml version="1.0" encoding="UTF-8"?>
<Rul xmlns = "OpenStaticAnalyzer" xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance">
  <ToolDescription>
    <Configuration name = "Default">
      <ToolDescriptionItem name = "ID">ESLint</ToolDescriptionItem>
    </Configuration>
  </ToolDescription>
  <Configurations/>
  <Views/>
  <Edges/>
  
  
<!-- ================= --> 
<!-- ESLINT categories -->
<!-- ================= -->
  <Metric id = "Possible Errors">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Possible Errors</DisplayName>
        <Description>These rules relate to possible syntax or logic errors in JavaScript code.</Description>
        <HelpText>These rules relate to possible syntax or logic errors in JavaScript code.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Best Practices">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Best Practices</DisplayName>
        <Description>These are rules designed to prevent you from making mistakes. They either prescribe a better way of doing something or help you avoid footguns.</Description>
        <HelpText>These are rules designed to prevent you from making mistakes. They either prescribe a better way of doing something or help you avoid footguns.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Strict Mode">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Strict Mode</DisplayName>
        <Description>These rules relate to using strict mode.</Description>
        <HelpText>These rules relate to using strict mode.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Variables">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Variables</DisplayName>
        <Description>These rules have to do with variable declarations.</Description>
        <HelpText>These rules have to do with variable declarations.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ECMAScript 6">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>ECMAScript 6</DisplayName>
        <Description>These rules are only relevant to ES6 environments.</Description>
        <HelpText>These rules are only relevant to ES6 environments.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Node.js and CommonJS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Node.js and CommonJS</DisplayName>
        <Description>These rules are specific to JavaScript running on Node.js or using CommonJS in the browser.</Description>
        <HelpText>These rules are specific to JavaScript running on Node.js or using CommonJS in the browser.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Stylistic Issues">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Stylistic Issues</DisplayName>
        <Description>These rules are purely matters of style and are quite subjective.</Description>
        <HelpText>These rules are purely matters of style and are quite subjective.</HelpText>
      </Language>
      <Baselines/>
      <Settings/>
      <Calculated/>
    </Configuration>
  </Metric>

<!-- ======================== -->
<!-- END OF ESLINT categories -->
<!-- ======================== -->






<!-- ============================================== -->
<!-- Possible Errors category in alphabetical order -->
<!-- ============================================== -->
  
  
  
  
  <Metric id = "ESLINT_FD">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>for-direction</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>for-direction</DisplayName>
        <Description> A for loop with a stop condition that can never be reached, such as one with a counter that moves in the wrong direction, will run infinitely. While there are occasions when an infinite loop is intended, the convention is to construct such loops as while loops. More typically, an infinite for loop is a bug.</Description>
        <HelpText>A for loop with a stop condition that can never be reached, such as one with a counter that moves in the wrong direction, will run infinitely. While there are occasions when an infinite loop is intended, the convention is to construct such loops as while loops. More typically, an infinite for loop is a bug.</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>

  <Metric id = "ESLINT_GRET">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>getter-return</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>getter-return</DisplayName>
        <Description>The get syntax binds an object property to a function that will be called when that property is looked up. Note that every getter is expected to return a value. This rule enforces that a return statement is present in property getters.</Description>
        <HelpText>The get syntax binds an object property to a function that will be called when that property is looked up. Note that every getter is expected to return a value. This rule enforces that a return statement is present in property getters.</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable="true">{ "allowImplicit": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NAIL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-await-in-loop</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-await-in-loop</DisplayName>
        <Description>Performing an operation on each element of an iterable is a common task. However, performing an await as part of each operation is an indication that the program is not taking full advantage of the parallelization benefits of async/await.</Description>
        <HelpText>Performing an operation on each element of an iterable is a common task. However, performing an await as part of each operation is an indication that the program is not taking full advantage of the parallelization benefits of async/await.</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCNZ">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-compare-neg-zero</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-compare-neg-zero</DisplayName>
        <Description>The rule should warn against code that tries to compare against -0, since that will not work as intended. That is, code like x === -0 will pass for both +0 and -0. The author probably intended Object.is(x, -0).</Description>
        <HelpText>The rule should warn against code that tries to compare against -0, since that will not work as intended. That is, code like x === -0 will pass for both +0 and -0. The author probably intended Object.is(x, -0).</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-cond-assign</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-cond-assign</DisplayName>
        <Description> In conditional statements, it is very easy to mistype a comparison operator (such as ==) as an assignment operator (such as =). For example: There are valid reasons to use assignment operators in conditional statements. However, it can be difficult to tell whether a specific assignment was intentional.</Description>
        <HelpText>&lt;p&gt;In conditional statements, it is very easy to mistype a comparison operator (such as ==) as an assignment operator (such as =). For example: There are valid reasons to use assignment operators in conditional statements. However, it can be difficult to tell whether a specific assignment was intentional.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">&quot;except-parens&quot;</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-console</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-console</DisplayName>
        <Description> In JavaScript that is designed to be executed in the browser, it&apos;s considered a best practice to avoid using methods on console. Such messages are considered to be for debugging purposes and therefore not suitable to ship to the client. In general, calls using console should be stripped before being pushed to production.</Description>
        <HelpText>&lt;p&gt;In JavaScript that is designed to be executed in the browser, it’s considered a best practice to avoid using methods on console. Such messages are considered to be for debugging purposes and therefore not suitable to ship to the client. In general, calls using console should be stripped before being pushed to production.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ &quot;allow&quot;: [&quot;warn&quot;, &quot;error&quot;] }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-constant-condition</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-constant-condition</DisplayName>
        <Description> Comparing a literal expression in a condition is usually a typo or development trigger for a specific behavior. This pattern is most likely an error and should be avoided.</Description>
        <HelpText>&lt;p&gt;Comparing a literal expression in a condition is usually a typo or development trigger for a specific behavior. This pattern is most likely an error and should be avoided.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable="true">{ "checkLoops": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCR">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-control-regex</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-control-regex</DisplayName>
        <Description> Control characters are special, invisible characters in the ASCII range 0-31. These characters are rarely used in JavaScript strings so a regular expression containing these characters is most likely a mistake.</Description>
        <HelpText>&lt;p&gt;Control characters are special, invisible characters in the ASCII range 0-31. These characters are rarely used in JavaScript strings so a regular expression containing these characters is most likely a mistake.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_ND">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-debugger</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-debugger</DisplayName>
        <Description> The debugger statement is used to tell the executing JavaScript environment to stop execution and start up a debugger at the current point in the code. This has fallen out of favor as a good practice with the advent of modern debugging and development tools. Production code should definitely not contain debugger, as it will cause the browser to stop executing code and open an appropriate debugger.</Description>
        <HelpText>&lt;p&gt;The debugger statement is used to tell the executing JavaScript environment to stop execution and start up a debugger at the current point in the code. This has fallen out of favor as a good practice with the advent of modern debugging and development tools. Production code should definitely not contain debugger, as it will cause the browser to stop executing code and open an appropriate debugger.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NDA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-dupe-args</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-dupe-args</DisplayName>
        <Description>If more than one parameter has the same name in a function definition, the last occurrence “shadows” the preceding occurrences. A duplicated name might be a typing error.</Description>
        <HelpText>&lt;p&gt;If more than one parameter has the same name in a function definition, the last occurrence “shadows” the preceding occurrences. A duplicated name might be a typing error.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NDK">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-dupe-keys</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-dupe-keys</DisplayName>
        <Description> Multiple properties with the same key in object literals can cause unexpected behavior in your application.</Description>
        <HelpText>&lt;p&gt;Multiple properties with the same key in object literals can cause unexpected behavior in your application.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NDC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-duplicate-case</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-duplicate-case</DisplayName>
        <Description> A switch statements with duplicate case labels is normally an indication of a programmer error. In the following example the 3rd case label uses again the literal 1 that has already been used in the first case label. Most likely the case block was copied from above and it was forgotten to change the literal.</Description>
        <HelpText>&lt;p&gt;A switch statements with duplicate case labels is normally an indication of a programmer error. In the following example the 3rd case label uses again the literal 1 that has already been used in the first case label. Most likely the case block was copied from above and it was forgotten to change the literal.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NE">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-empty</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-empty</DisplayName>
        <Description> Empty block statements, while not technically errors, usually occur due to refactoring that wasn’t completed. They can cause confusion when reading code.</Description>
        <HelpText>&lt;p&gt;Empty block statements, while not technically errors, usually occur due to refactoring that wasn’t completed. They can cause confusion when reading code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "allowEmptyCatch": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NECC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-empty-character-class</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-empty-character-class</DisplayName>
        <Description> Empty character classes in regular expressions do not match anything and can result in code that may not work as intended.</Description>
        <HelpText>&lt;p&gt;Empty character classes in regular expressions do not match anything and can result in code that may not work as intended.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-ex-assign</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-ex-assign</DisplayName>
        <Description> If a catch clause in a try statement accidentally (or purposely) assigns another value to the exception parameter, it impossible to refer to the error from that point on. Since there is no arguments object to offer alternative access to this data, assignment of the parameter is absolutely destructive.</Description>
        <HelpText>&lt;p&gt;If a catch clause in a try statement accidentally (or purposely) assigns another value to the exception parameter, it impossible to refer to the error from that point on. Since there is no arguments object to offer alternative access to this data, assignment of the parameter is absolutely destructive.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEBC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-extra-boolean-cast</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-extra-boolean-cast</DisplayName>
        <Description> In contexts such as an if statement&apos;s test where the result of the expression will already be coerced to a Boolean, casting to a Boolean via double negation (!!) is unnecessary. For example, these if statements are equivalent:</Description>
        <HelpText>&lt;p&gt;In contexts such as an if statement’s test where the result of the expression will already be coerced to a Boolean, casting to a Boolean via double negation (!!) is unnecessary. For example, these if statements are equivalent:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-extra-parens</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-extra-parens</DisplayName>
        <Description> This rule restricts the use of parentheses to only where they are necessary. It may be restricted to report only function expressions.</Description>
        <HelpText>&lt;p&gt;This rule restricts the use of parentheses to only where they are necessary. It may be restricted to report only function expressions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"all"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NES">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-extra-semi</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-extra-semi</DisplayName>
        <Description> Typing mistakes and misunderstandings about where semicolons are required can lead to semicolons that are unnecessary. While not technically an error, extra semicolons can cause confusion when reading code.</Description>
        <HelpText>&lt;p&gt;Typing mistakes and misunderstandings about where semicolons are required can lead to semicolons that are unnecessary. While not technically an error, extra semicolons can cause confusion when reading code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NFA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-func-assign</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-func-assign</DisplayName>
        <Description> JavaScript functions can be written as a FunctionDeclaration function foo() { ... } or as a FunctionExpression var foo = function() { ... };. While a JavaScript interpreter might tolerate it, overwriting/reassigning a function written as a FunctionDeclaration is often indicative of a mistake or issue.</Description>
        <HelpText>&lt;p&gt;JavaScript functions can be written as a FunctionDeclaration function foo() { … } or as a FunctionExpression var foo = function() { … };. While a JavaScript interpreter might tolerate it, overwriting/reassigning a function written as a FunctionDeclaration is often indicative of a mistake or issue.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NID">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-inner-declarations</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-inner-declarations</DisplayName>
        <Description> In JavaScript, prior to ES6, a function declaration is only allowed in the first level of a program or the body of another function, though parsers sometimes erroneously accept them elsewhere. This only applies to function declarations; named or anonymous function expressions can occur anywhere an expression is permitted. A variable declaration is permitted anywhere a statement can go, even nested deeply inside other blocks. This is often undesirable due to variable hoisting, and moving declarations to the root of the program or function body can increase clarity. Note that block bindings (let, const) are not hoisted and therefore they are not affected by this rule.</Description>
        <HelpText>&lt;p&gt;In JavaScript, prior to ES6, a function declaration is only allowed in the first level of a program or the body of another function, though parsers sometimes erroneously accept them elsewhere. This only applies to function declarations; named or anonymous function expressions can occur anywhere an expression is permitted. A variable declaration is permitted anywhere a statement can go, even nested deeply inside other blocks. This is often undesirable due to variable hoisting, and moving declarations to the root of the program or function body can increase clarity. Note that block bindings (let, const) are not hoisted and therefore they are not affected by this rule.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"functions"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NIR">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-invalid-regexp</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-invalid-regexp</DisplayName>
        <Description> An invalid pattern in a regular expression literal is a SyntaxError when the code is parsed, but an invalid string in RegExp constructors throws a SyntaxError only when the code is executed.</Description>
        <HelpText>&lt;p&gt;An invalid pattern in a regular expression literal is a SyntaxError when the code is parsed, but an invalid string in RegExp constructors throws a SyntaxError only when the code is executed.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "allowConstructorFlags": ["u", "y"] }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NIW">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-irregular-whitespace</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-irregular-whitespace</DisplayName>
        <Description> Invalid or irregular whitespace causes issues with ECMAScript 5 parsers and also makes code harder to debug in a similar nature to mixed tabs and spaces. Various whitespace characters can be inputted by programmers by mistake for example from copying or keyboard shortcuts. Pressing Alt + Space on OS X adds in a non breaking space character for example. Known issues these spaces cause:</Description>
        <HelpText>&lt;p&gt;Invalid or irregular whitespace causes issues with ECMAScript 5 parsers and also makes code harder to debug in a similar nature to mixed tabs and spaces. Various whitespace characters can be inputted by programmers by mistake for example from copying or keyboard shortcuts. Pressing Alt + Space on OS X adds in a non breaking space character for example. Known issues these spaces cause:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "skipStrings": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NOC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-obj-calls</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-obj-calls</DisplayName>
        <Description> ECMAScript provides several global objects that are intended to be used as-is. Some of these objects look as if they could be constructors due their capitalization (such as Math and JSON) but will throw an error if you try to execute them as functions. The ECMAScript 5 specification makes it clear that both Math and JSON cannot be invoked:</Description>
        <HelpText>&lt;p&gt;ECMAScript provides several global objects that are intended to be used as-is. Some of these objects look as if they could be constructors due their capitalization (such as Math and JSON) but will throw an error if you try to execute them as functions. The ECMAScript 5 specification makes it clear that both Math and JSON cannot be invoked:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-prototype-builtins</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-prototype-builtins</DisplayName>
        <Description> In ECMAScript 5.1, Object.create was added, which enables the creation of objects with a specified [[Prototype]]. Object.create(null) is a common pattern used to create objects that will be used as a Map. This can lead to errors when it is assumed that objects will have properties from Object.prototype. This rule prevents calling Object.prototype methods directly from an object.</Description>
        <HelpText>&lt;p&gt;In ECMAScript 5.1, Object.create was added, which enables the creation of objects with a specified [[Prototype]]. Object.create(null) is a common pattern used to create objects that will be used as a Map. This can lead to errors when it is assumed that objects will have properties from Object.prototype. This rule prevents calling Object.prototype methods directly from an object.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-regex-spaces</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-regex-spaces</DisplayName>
        <Description> Regular expressions can be very complex and difficult to understand, which is why it&apos;s important to keep them as simple as possible in order to avoid mistakes. One of the more error-prone things you can do with a regular expression is to use more than one space, such as: In this regular expression, it&apos;s very hard to tell how many spaces are intended to be matched. It&apos;s better to use only one space and then specify how many spaces are expected, such as: Now it is very clear that three spaces are expected to be matched.</Description>
        <HelpText>&lt;p&gt;Regular expressions can be very complex and difficult to understand, which is why it’s important to keep them as simple as possible in order to avoid mistakes. One of the more error-prone things you can do with a regular expression is to use more than one space, such as: In this regular expression, it’s very hard to tell how many spaces are intended to be matched. It’s better to use only one space and then specify how many spaces are expected, such as: Now it is very clear that three spaces are expected to be matched.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-sparse-arrays</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-sparse-arrays</DisplayName>
        <Description> Sparse arrays contain empty slots, most frequently due to multiple commas being used in an array literal, such as: While the items array in this example has a length of 2, there are actually no values in items[0] or items[1]. The fact that the array literal is valid with only commas inside, coupled with the length being set and actual item values not being set, make sparse arrays confusing for many developers. Consider the following: In this example, the colors array has a length of 3. But did the developer intend for there to be an empty spot in the middle of the array? Or is it a typo? The confusion around sparse arrays defined in this manner is enough that it&apos;s recommended to avoid using them unless you are certain that they are useful in your code.</Description>
        <HelpText>&lt;p&gt;Sparse arrays contain empty slots, most frequently due to multiple commas being used in an array literal, such as: While the items array in this example has a length of 2, there are actually no values in items[0] or items[1]. The fact that the array literal is valid with only commas inside, coupled with the length being set and actual item values not being set, make sparse arrays confusing for many developers. Consider the following: In this example, the colors array has a length of 3. But did the developer intend for there to be an empty spot in the middle of the array? Or is it a typo? The confusion around sparse arrays defined in this manner is enough that it’s recommended to avoid using them unless you are certain that they are useful in your code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NTCIS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-template-curly-in-string</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-template-curly-in-string</DisplayName>
        <Description> ECMAScript 6 allows programmers to create strings containing variable or expressions using template literals, instead of string concatenation, by writing expressions like ${variable} between two backtick quotes (`). It can be easy to use the wrong quotes when wanting to use template literals, by writing "${variable}", and end up with the literal value "${variable}" instead of a string containing the value of the injected expressions.</Description>
        <HelpText>&lt;p&gt;ECMAScript 6 allows programmers to create strings containing variable or expressions using template literals, instead of string concatenation, by writing expressions like ${variable} between two backtick quotes (`). It can be easy to use the wrong quotes when wanting to use template literals, by writing "${variable}", and end up with the literal value "${variable}" instead of a string containing the value of the injected expressions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUM">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-unexpected-multiline</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unexpected-multiline</DisplayName>
        <Description> Semicolons are optional in JavaScript, via a process called automatic semicolon insertion (ASI). See the documentation for semi for a fuller discussion of that feature. The rules for ASI are relatively straightforward: In short, as once described by Isaac Schlueter, a \n character always ends a statement (just like a semicolon) unless one of the following is true: This particular rule aims to spot scenarios where a newline looks like it is ending a statement, but is not.</Description>
        <HelpText>&lt;p&gt;Semicolons are optional in JavaScript, via a process called automatic semicolon insertion (ASI). See the documentation for semi for a fuller discussion of that feature. The rules for ASI are relatively straightforward: In short, as once described by Isaac Schlueter, a character always ends a statement (just like a semicolon) unless one of the following is true: This particular rule aims to spot scenarios where a newline looks like it is ending a statement, but is not.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NU">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-unreachable</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unreachable</DisplayName>
        <Description>Because the return, throw, break, and continue statements unconditionally exit a block of code, any statements after them cannot be executed. Unreachable statements are usually a mistake.</Description>
        <HelpText>&lt;p&gt;Because the return, throw, break, and continue statements unconditionally exit a block of code, any statements after them cannot be executed. Unreachable statements are usually a mistake.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUF">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-unsafe-finally</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unsafe-finally</DisplayName>
        <Description>JavaScript suspends the control flow statements of try and catch blocks until the execution of finally block finishes. So, when return, throw, break, or continue is used in finally, control flow statements inside try and catch are overwritten, which is considered as unexpected behavior.</Description>
        <HelpText>&lt;p&gt;JavaScript suspends the control flow statements of try and catch blocks until the execution of finally block finishes. So, when return, throw, break, or continue is used in finally, control flow statements inside try and catch are overwritten, which is considered as unexpected behavior.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUNEG">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-unsafe-negation</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unsafe-negation</DisplayName>
        <Description>Just as developers might type -a + b when they mean -(a + b) for the negative of a sum, they might type !key in object by mistake when they almost certainly mean !(key in object) to test that a key is not in an object. !obj instanceof Ctor is similar.</Description>
        <HelpText>&lt;p&gt;Just as developers might type -a + b when they mean -(a + b) for the negative of a sum, they might type !key in object by mistake when they almost certainly mean !(key in object) to test that a key is not in an object. !obj instanceof Ctor is similar.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_UI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>use-isnan</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>use-isnan</DisplayName>
        <Description> In JavaScript, NaN is a special value of the Number type. It&apos;s used to represent any of the &quot;not-a-number&quot; values represented by the double-precision 64-bit format as specified by the IEEE Standard for Binary Floating-Point Arithmetic. NaN has the unique property of not being equal to anything, including itself. That is to say, that the condition NaN !== NaN evaluates to true.</Description>
        <HelpText>&lt;p&gt;In JavaScript, NaN is a special value of the Number type. It’s used to represent any of the “not-a-number” values represented by the double-precision 64-bit format as specified by the IEEE Standard for Binary Floating-Point Arithmetic. NaN has the unique property of not being equal to anything, including itself. That is to say, that the condition NaN !== NaN evaluates to true.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_VJ">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>valid-jsdoc</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>valid-jsdoc</DisplayName>
        <Description> JSDoc is a JavaScript API documentation generator. It uses specially-formatted comments inside of code to generate API documentation automatically. For example, this is what a JSDoc comment looks like for a function: The JSDoc comments have a syntax all their own, and it is easy to mistakenly mistype a comment because comments aren&apos;t often checked for correctness in editors. Further, it&apos;s very easy for the function definition to get out of sync with the comments, making the comments a source of confusion and error.</Description>
        <HelpText>&lt;p&gt;JSDoc is a JavaScript API documentation generator. It uses specially-formatted comments inside of code to generate API documentation automatically. For example, this is what a JSDoc comment looks like for a function: The JSDoc comments have a syntax all their own, and it is easy to mistakenly mistype a comment because comments aren’t often checked for correctness in editors. Further, it’s very easy for the function definition to get out of sync with the comments, making the comments a source of confusion and error.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "requireReturn": false
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_VT">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>valid-typeof</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>valid-typeof</DisplayName>
        <Description> For a vast majority of use-cases, the only valid results of the typeof operator will be one of the following: &quot;undefined&quot;, &quot;object&quot;, &quot;boolean&quot;, &quot;number&quot;, &quot;string&quot;, and &quot;function&quot;. When the result of a typeof operation is compared against a string that is not one of these strings, it is usually a typo. This rule ensures that when the result of a typeof operation is compared against a string, that string is in the aforementioned set.</Description>
        <HelpText>&lt;p&gt;For a vast majority of use-cases, the only valid results of the typeof operator will be one of the following: “undefined”, “object”, “boolean”, “number”, “string”, and “function”. When the result of a typeof operation is compared against a string that is not one of these strings, it is usually a typo. This rule ensures that when the result of a typeof operation is compared against a string, that string is in the aforementioned set.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "requireStringLiterals": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  
<!-- =============================== -->
<!-- END OF Possible Errors category -->
<!-- =============================== -->
  
  
  
<!-- =========================== -->
<!-- Best Practices category -->
<!-- =========================== -->
  <Metric id = "ESLINT_AP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>accessor-pairs</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>accessor-pairs</DisplayName>
        <Description> It&apos;s a common mistake in JavaScript to create an object with just a setter for a property but never have a corresponding getter defined for it. Without a getter, you cannot read the property, so it ends up not being used. Here are some examples: This rule warns if setters are defined without getters. Using an option getWithoutSet, it will warn if you have a getter without a setter also.</Description>
        <HelpText>&lt;p&gt;It’s a common mistake in JavaScript to create an object with just a setter for a property but never have a corresponding getter defined for it. Without a getter, you cannot read the property, so it ends up not being used. Here are some examples: This rule warns if setters are defined without getters. Using an option getWithoutSet, it will warn if you have a getter without a setter also.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">
        {
            "setWithoutGet": true,
			"getWithoutSet": false
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_ACR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>array-callback-return</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>array-callback-return</DisplayName>
        <Description> Array has several methods for filtering, mapping, and folding. If we forget to write return statement in a callback of those, it’s probably a mistake.</Description>
        <HelpText>&lt;p&gt;Array has several methods for filtering, mapping, and folding. If we forget to write return statement in a callback of those, it’s probably a mistake.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">
        {
            "allowImplicit": false
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_BSV">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>block-scoped-var</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>block-scoped-var</DisplayName>
        <Description> The block-scoped-var rule generates warnings when variables are used outside of the block in which they were defined. This emulates C-style block scope.</Description>
        <HelpText>&lt;p&gt;The block-scoped-var rule generates warnings when variables are used outside of the block in which they were defined. This emulates C-style block scope.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CMUT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>class-methods-use-this</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>class-methods-use-this</DisplayName>
        <Description> If a class method does not use this, it can sometimes be made into a static function. If you do convert the method into a static function, instances of the class that call that particular method have to be converted to a static call as well (MyClass.callStaticMethod())</Description>
        <HelpText>&lt;p&gt;If a class method does not use this, it can sometimes be made into a static function. If you do convert the method into a static function, instances of the class that call that particular method have to be converted to a static call as well (MyClass.callStaticMethod())&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_C">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>complexity</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>complexity</DisplayName>
        <Description> Cyclomatic complexity measures the number of linearly independent paths through a program&apos;s source code. This rule allows setting a cyclomatic complexity threshold.</Description>
        <HelpText>&lt;p&gt;Cyclomatic complexity measures the number of linearly independent paths through a program’s source code. This rule allows setting a cyclomatic complexity threshold.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 2 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>consistent-return</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>consistent-return</DisplayName>
        <Description> One of the confusing aspects of JavaScript is that any function may or may not return a value at any point in time. When a function exits without any return statement executing, the function returns undefined. Similarly, calling return without specifying any value will cause the function to return undefined. Only when return is called with a value is there a change in the function&apos;s return value. Unlike statically-typed languages that will catch when a function doesn&apos;t return the type of data expected, JavaScript has no such checks, meaning that it&apos;s easy to make mistakes such as this: Here, one branch of the function returns true, a Boolean value, while the other exits without specifying any value (and so returns undefined). This may be an indicator of a coding error, especially if this pattern is found in larger functions.</Description>
        <HelpText>&lt;p&gt;One of the confusing aspects of JavaScript is that any function may or may not return a value at any point in time. When a function exits without any return statement executing, the function returns undefined. Similarly, calling return without specifying any value will cause the function to return undefined. Only when return is called with a value is there a change in the function’s return value. Unlike statically-typed languages that will catch when a function doesn’t return the type of data expected, JavaScript has no such checks, meaning that it’s easy to make mistakes such as this: Here, one branch of the function returns true, a Boolean value, while the other exits without specifying any value (and so returns undefined). This may be an indicator of a coding error, especially if this pattern is found in larger functions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{"treatUndefinedAsUnspecified": false}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CU">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>curly</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>curly</DisplayName>
        <Description> JavaScript allows the omission of curly braces when a block contains only one statement. However, it is considered by many to be best practice to never omit curly braces around blocks, even when they are optional, because it can lead to bugs and reduces code clarity. So the following: Can be rewritten as: There are, however, some who prefer to only use braces when there is more than one statement to be executed.</Description>
        <HelpText>&lt;p&gt;JavaScript allows the omission of curly braces when a block contains only one statement. However, it is considered by many to be best practice to never omit curly braces around blocks, even when they are optional, because it can lead to bugs and reduces code clarity. So the following: Can be rewritten as: There are, however, some who prefer to only use braces when there is more than one statement to be executed.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"all"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_DC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>default-case</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>default-case</DisplayName>
        <Description> Some code conventions require that all switch statements have a default case, even if the default case is empty, such as: The thinking is that it&apos;s better to always explicitly state what the default behavior should be so that it&apos;s clear whether or not the developer forgot to include the default behavior by mistake. Other code conventions allow you to skip the default case so long as there is a comment indicating the omission is intentional, such as: Once again, the intent here is to show that the developer intended for there to be no default behavior.</Description>
        <HelpText>&lt;p&gt;Some code conventions require that all switch statements have a default case, even if the default case is empty, such as: The thinking is that it’s better to always explicitly state what the default behavior should be so that it’s clear whether or not the developer forgot to include the default behavior by mistake. Other code conventions allow you to skip the default case so long as there is a comment indicating the omission is intentional, such as: Once again, the intent here is to show that the developer intended for there to be no default behavior.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{"commentPattern":"/^no default$/i"}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_DL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>dot-location</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>dot-location</DisplayName>
        <Description> JavaScript allows you to place newlines before or after a dot in a member expression. Consistency in placing a newline before or after the dot can greatly increase readability.</Description>
        <HelpText>&lt;p&gt;JavaScript allows you to place newlines before or after a dot in a member expression. Consistency in placing a newline before or after the dot can greatly increase readability.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">"object"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_DN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>dot-notation</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>dot-notation</DisplayName>
        <Description> In JavaScript, one can access properties using the dot notation (foo.bar) or square-bracket notation (foo[&quot;bar&quot;]). However, the dot notation is often preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.</Description>
        <HelpText>&lt;p&gt;In JavaScript, one can access properties using the dot notation (foo.bar) or square-bracket notation (foo[“bar”]). However, the dot notation is often preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "allowKeywords": true
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_E">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>eqeqeq</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>eqeqeq</DisplayName>
        <Description> It is considered good practice to use the type-safe equality operators === and !== instead of their regular counterparts == and !=. The reason for this is that == and != do type coercion which follows the rather obscure Abstract Equality Comparison Algorithm. For instance, the following statements are all considered true: If one of those occurs in an innocent-looking statement such as a == b the actual problem is very difficult to spot.</Description>
        <HelpText>&lt;p&gt;It is considered good practice to use the type-safe equality operators === and !== instead of their regular counterparts == and !=. The reason for this is that == and != do type coercion which follows the rather obscure Abstract Equality Comparison Algorithm. For instance, the following statements are all considered true: If one of those occurs in an innocent-looking statement such as a == b the actual problem is very difficult to spot.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">&quot;always&quot;</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_GFI">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>guard-for-in</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>guard-for-in</DisplayName>
        <Description> Looping over objects with a for in loop will include properties that are inherited through the prototype chain. This behavior can lead to unexpected items in your for loop.</Description>
        <HelpText>&lt;p&gt;Looping over objects with a for in loop will include properties that are inherited through the prototype chain. This behavior can lead to unexpected items in your for loop.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-alert</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-alert</DisplayName>
        <Description> JavaScripts&apos; alert, confirm, and prompt functions are widely considered to be obtrusive as UI elements and should be replaced by a more appropriate custom UI implementation. Furthermore, alert is often used while debugging code, which should be removed before deployment to production.</Description>
        <HelpText>&lt;p&gt;JavaScripts’ alert, confirm, and prompt functions are widely considered to be obtrusive as UI elements and should be replaced by a more appropriate custom UI implementation. Furthermore, alert is often used while debugging code, which should be removed before deployment to production.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCAL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-caller</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-caller</DisplayName>
        <Description> The use of arguments.caller and arguments.callee make several code optimizations impossible. They have been deprecated in future versions of JavaScript and their use is forbidden in ECMAScript 5 while in strict mode.</Description>
        <HelpText>&lt;p&gt;The use of arguments.caller and arguments.callee make several code optimizations impossible. They have been deprecated in future versions of JavaScript and their use is forbidden in ECMAScript 5 while in strict mode.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCD">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-case-declarations</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-case-declarations</DisplayName>
        <Description> This rule disallows lexical declarations (let, const, function and class) in case/default clauses. The reason is that the lexical declaration is visible in the entire switch block but it only gets initialized when it is assigned, which will only happen if the case where it is defined is reached. To ensure that the lexical declaration only applies to the current case clause wrap your clauses in blocks.</Description>
        <HelpText>&lt;p&gt;This rule disallows lexical declarations (let, const, function and class) in case/default clauses. The reason is that the lexical declaration is visible in the entire switch block but it only gets initialized when it is assigned, which will only happen if the case where it is defined is reached. To ensure that the lexical declaration only applies to the current case clause wrap your clauses in blocks.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NDR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-div-regex</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-div-regex</DisplayName>
        <Description> Require regex literals to escape division operators.</Description>
        <HelpText>&lt;p&gt;Require regex literals to escape division operators.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NER">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-else-return</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-else-return</DisplayName>
        <Description> If an if block contains a return statement, the else block becomes unnecessary. Its contents can be placed outside of the block.</Description>
        <HelpText>&lt;p&gt;If an if block contains a return statement, the else block becomes unnecessary. Its contents can be placed outside of the block.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{"allowElseIf": true}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEF">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-empty-function</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-empty-function</DisplayName>
        <Description> Empty functions can reduce readability because readers need to guess whether it’s intentional or not. So writing a clear comment for empty functions is a good practice.</Description>
        <HelpText>&lt;p&gt;Empty functions can reduce readability because readers need to guess whether it’s intentional or not. So writing a clear comment for empty functions is a good practice.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{"allow": []}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEPA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-empty-pattern</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-empty-pattern</DisplayName>
        <Description> When using destructuring, it&apos;s possible to create a pattern that has no effect. This happens when empty curly braces are used to the right of an embedded object destructuring pattern, such as: In this code, no new variables are created because a is just a location helper while the {} is expected to contain the variables to create, such as: In many cases, the empty object pattern is a mistake where the author intended to use a default value instead, such as: The difference between these two patterns is subtle, especially because the problematic empty pattern looks just like an object literal.</Description>
        <HelpText>&lt;p&gt;When using destructuring, it’s possible to create a pattern that has no effect. This happens when empty curly braces are used to the right of an embedded object destructuring pattern, such as: In this code, no new variables are created because a is just a location helper while the {} is expected to contain the variables to create, such as: In many cases, the empty object pattern is a mistake where the author intended to use a default value instead, such as: The difference between these two patterns is subtle, especially because the problematic empty pattern looks just like an object literal.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-eq-null</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-eq-null</DisplayName>
        <Description> Comparing to null without a type-checking operator (== or !=), can have unintended results as the comparison will evaluate to true when comparing to not just a null, but also an undefined value.</Description>
        <HelpText>&lt;p&gt;Comparing to null without a type-checking operator (== or !=), can have unintended results as the comparison will evaluate to true when comparing to not just a null, but also an undefined value.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEV">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-eval</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-eval</DisplayName>
        <Description> JavaScript&apos;s eval() function is potentially dangerous and is often misused. Using eval() on untrusted code can open a program up to several different injection attacks. The use of eval() in most contexts can be substituted for a better, alternative approach to a problem.</Description>
        <HelpText>&lt;p&gt;JavaScript’s eval() function is potentially dangerous and is often misused. Using eval() on untrusted code can open a program up to several different injection attacks. The use of eval() in most contexts can be substituted for a better, alternative approach to a problem.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{"allowIndirect": true}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NENA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-extend-native</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-extend-native</DisplayName>
        <Description> In JavaScript, you can extend any object, including builtin or &quot;native&quot; objects. Sometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code. For example here we are overriding a builtin method that will then affect all Objects, even other builtins. A common suggestion to avoid this problem would be to wrap the inside of the for loop with users.hasOwnProperty(id). However, if this rule is strictly enforced throughout your codebase you won&apos;t need to take that step.</Description>
        <HelpText>&lt;p&gt;In JavaScript, you can extend any object, including builtin or “native” objects. Sometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code. For example here we are overriding a builtin method that will then affect all Objects, even other builtins. A common suggestion to avoid this problem would be to wrap the inside of the for loop with users.hasOwnProperty(id). However, if this rule is strictly enforced throughout your codebase you won’t need to take that step.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{"exceptions": []}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NEB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-extra-bind</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-extra-bind</DisplayName>
        <Description> The bind() method is used to create functions with specific this values and, optionally, binds arguments to specific values. When used to specify the value of this, it&apos;s important that the function actually use this in its function body. For example: This code is an example of a good use of bind() for setting the value of this. Sometimes during the course of code maintenance, the this value is removed from the function body. In that case, you can end up with a call to bind() that doesn&apos;t accomplish anything: In this code, the reference to this has been removed but bind() is still used. In this case, the bind() is unnecessary overhead (and a performance hit) and can be safely removed.</Description>
        <HelpText>&lt;p&gt;The bind() method is used to create functions with specific this values and, optionally, binds arguments to specific values. When used to specify the value of this, it’s important that the function actually use this in its function body. For example: This code is an example of a good use of bind() for setting the value of this. Sometimes during the course of code maintenance, the this value is removed from the function body. In that case, you can end up with a call to bind() that doesn’t accomplish anything: In this code, the reference to this has been removed but bind() is still used. In this case, the bind() is unnecessary overhead (and a performance hit) and can be safely removed.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NELA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-extra-label</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-extra-label</DisplayName>
        <Description> The --fix option on the command line can automatically fix some of the problems reported by this rule.If a loop contains no nested loops or switches, labeling the loop is unnecessary.</Description>
        <HelpText>&lt;p&gt;The --fix option on the command line can automatically fix some of the problems reported by this rule.If a loop contains no nested loops or switches, labeling the loop is unnecessary.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NF">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-fallthrough</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-fallthrough</DisplayName>
        <Description> The switch statement in JavaScript is one of the more error-prone constructs of the language thanks in part to the ability to &quot;fall through&quot; from one case to the next. For example: In this example, if foo is 1,then execution will flow through both cases, as the first falls through to the second. You can prevent this by using break, as in this example: That works fine when you don&apos;t want a fallthrough, but what if the fallthrough is intentional, there is no way to indicate that in the language. It&apos;s considered a best practice to always indicate when a fallthrough is intentional using a comment: In this example, there is no confusion as to the expected behavior. It is clear that the first case is meant to fall through to the second case.</Description>
        <HelpText>&lt;p&gt;The switch statement in JavaScript is one of the more error-prone constructs of the language thanks in part to the ability to “fall through” from one case to the next. For example: In this example, if foo is 1,then execution will flow through both cases, as the first falls through to the second. You can prevent this by using break, as in this example: That works fine when you don’t want a fallthrough, but what if the fallthrough is intentional, there is no way to indicate that in the language. It’s considered a best practice to always indicate when a fallthrough is intentional using a comment: In this example, there is no confusion as to the expected behavior. It is clear that the first case is meant to fall through to the second case.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "commentPattern": "break[\\s\\w]*omitted" }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NFD">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-floating-decimal</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-floating-decimal</DisplayName>
        <Description> Float values in JavaScript contain a decimal point, and there is no requirement that the decimal point be preceded or followed by a number. For example, the following are all valid JavaScript numbers: Although not a syntax error, this format for numbers can make it difficult to distinguish between true decimal numbers and the dot operator. For this reason, some recommend that you should always include a number before and after a decimal point to make it clear the intent is to create a decimal number.</Description>
        <HelpText>&lt;p&gt;Float values in JavaScript contain a decimal point, and there is no requirement that the decimal point be preceded or followed by a number. For example, the following are all valid JavaScript numbers: Although not a syntax error, this format for numbers can make it difficult to distinguish between true decimal numbers and the dot operator. For this reason, some recommend that you should always include a number before and after a decimal point to make it clear the intent is to create a decimal number.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NGA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-global-assign</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-global-assign</DisplayName>
        <Description> JavaScript environments contain a number of built-in global variables, such as window in browsers and process in Node.js. In almost all cases, you don’t want to assign a value to these global variables as doing so could result in losing access to important functionality.</Description>
        <HelpText>&lt;p&gt;JavaScript environments contain a number of built-in global variables, such as window in browsers and process in Node.js. In almost all cases, you don’t want to assign a value to these global variables as doing so could result in losing access to important functionality. &lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{ "exceptions": ["Object"] }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NIC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-implicit-coercion</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-implicit-coercion</DisplayName>
        <Description> In JavaScript, there are a lot of different ways to convert value types. Some of them might be hard to read and understand. Such as: Those can be replaced with the following code:</Description>
        <HelpText>&lt;p&gt;In JavaScript, there are a lot of different ways to convert value types. Some of them might be hard to read and understand. Such as: Those can be replaced with the following code:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{
			"boolean": true,
			"number": true,
			"string": true,
			"allow": []
		}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NIG">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-implicit-globals</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-implicit-globals</DisplayName>
        <Description> When working with browser scripts, developers often forget that variable and function declarations at the top-level scope become global variables on the window object. As opposed to modules which have their own scope. Globals should be explicitly assigned to window or self if that is the intent. Otherwise variables intended to be local to the script should be wrapped in an IIFE.</Description>
        <HelpText>&lt;p&gt;When working with browser scripts, developers often forget that variable and function declarations at the top-level scope become global variables on the window object. As opposed to modules which have their own scope. Globals should be explicitly assigned to window or self if that is the intent. Otherwise variables intended to be local to the script should be wrapped in an IIFE.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NIE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-implied-eval</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-implied-eval</DisplayName>
        <Description> It&apos;s considered a good practice to avoid using eval() in JavaScript. There are security and performance implications involved with doing so, which is why many linters (including ESLint) recommend disallowing eval(). However, there are some other ways to pass a string and have it interpreted as JavaScript code that have similar concerns. The first is using setTimeout(), setInterval() or execScript() (Internet Explorer only), both of which can accept a string of JavaScript code as their first argument. For example: This is considered an implied eval() because a string of JavaScript code is passed in to be interpreted. The same can be done with setInterval() and execScript(). Both interpret the JavaScript code in the global scope. For both setTimeout() and setInterval(), the first argument can also be a function, and that is considered safer and is more performant: The best practice is to always use a function for the first argument of setTimeout() and setInterval() (and avoid execScript()).</Description>
        <HelpText>&lt;p&gt;It’s considered a good practice to avoid using eval() in JavaScript. There are security and performance implications involved with doing so, which is why many linters (including ESLint) recommend disallowing eval(). However, there are some other ways to pass a string and have it interpreted as JavaScript code that have similar concerns. The first is using setTimeout(), setInterval() or execScript() (Internet Explorer only), both of which can accept a string of JavaScript code as their first argument. For example: This is considered an implied eval() because a string of JavaScript code is passed in to be interpreted. The same can be done with setInterval() and execScript(). Both interpret the JavaScript code in the global scope. For both setTimeout() and setInterval(), the first argument can also be a function, and that is considered safer and is more performant: The best practice is to always use a function for the first argument of setTimeout() and setInterval() (and avoid execScript()).&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NIT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-invalid-this</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-invalid-this</DisplayName>
        <Description> Under the strict mode, this keywords outside of classes or class-like objects might be undefined and raise a TypeError.</Description>
        <HelpText>&lt;p&gt;Under the strict mode, this keywords outside of classes or class-like objects might be undefined and raise a TypeError.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-iterator</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-iterator</DisplayName>
        <Description> The __iterator__ property was a SpiderMonkey extension to JavaScript that could be used to create custom iterators that are compatible with JavaScript&apos;s for in and for each constructs. However, this property is now obsolete, so it should not be used. Here&apos;s an example of how this used to work: You should use ECMAScript 6 iterators and generators instead.</Description>
        <HelpText>&lt;p&gt;The &lt;strong&gt;iterator&lt;/strong&gt; property was a SpiderMonkey extension to JavaScript that could be used to create custom iterators that are compatible with JavaScript’s for in and for each constructs. However, this property is now obsolete, so it should not be used. Here’s an example of how this used to work: You should use ECMAScript 6 iterators and generators instead.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-labels</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-labels</DisplayName>
        <Description> Labeled statements in JavaScript are used in conjunction with break and continue to control flow around multiple loops. For example: The break outer statement ensures that this code will not result in an infinite loop because control is returned to the next statement after the outer label was applied. If this statement was changed to be just break, control would flow back to the outer while statement and an infinite loop would result. While convenient in some cases, labels tend to be used only rarely and are frowned upon by some as a remedial form of flow control that is more error prone and harder to understand.</Description>
        <HelpText>&lt;p&gt;Labeled statements in JavaScript are used in conjunction with break and continue to control flow around multiple loops. For example: The break outer statement ensures that this code will not result in an infinite loop because control is returned to the next statement after the outer label was applied. If this statement was changed to be just break, control would flow back to the outer while statement and an infinite loop would result. While convenient in some cases, labels tend to be used only rarely and are frowned upon by some as a remedial form of flow control that is more error prone and harder to understand.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{"allowLoop": false, "allowSwitch": false}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NLB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-lone-blocks</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-lone-blocks</DisplayName>
        <Description> In JavaScript, prior to ES6, standalone code blocks delimited by curly braces do not create a new scope and have no use. For example, these curly braces do nothing to foo: In ES6, code blocks may create a new scope if a block-level binding (let and const), a class declaration or a function declaration (in strict mode) are present. A block is not considered redundant in these cases.</Description>
        <HelpText>&lt;p&gt;In JavaScript, prior to ES6, standalone code blocks delimited by curly braces do not create a new scope and have no use. For example, these curly braces do nothing to foo: In ES6, code blocks may create a new scope if a block-level binding (let and const), a class declaration or a function declaration (in strict mode) are present. A block is not considered redundant in these cases.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NLF">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-loop-func</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-loop-func</DisplayName>
        <Description> Writing functions within loops tends to result in errors due to the way the function creates a closure around the loop. For example: In this case, you would expect each function created within the loop to return a different number. In reality, each function returns 10, because that was the last value of i in the scope. let or const mitigate this problem. In this case, each function created within the loop returns a different number as expected.</Description>
        <HelpText>&lt;p&gt;Writing functions within loops tends to result in errors due to the way the function creates a closure around the loop. For example: In this case, you would expect each function created within the loop to return a different number. In reality, each function returns 10, because that was the last value of i in the scope. let or const mitigate this problem. In this case, each function created within the loop returns a different number as expected.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMN">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-magic-numbers</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-magic-numbers</DisplayName>
        <Description> &apos;Magic numbers&apos; are numbers that occur multiple time in code without an explicit meaning. They should preferably be replaced by named constants.</Description>
        <HelpText>&lt;p&gt;‘Magic numbers’ are numbers that occur multiple time in code without an explicit meaning. They should preferably be replaced by named constants.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{
			"ignore": [],
			"ignoreArrayIndexes": false,
			"enforceConst": false,
			"detectObjects": false
		}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-multi-spaces</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-multi-spaces</DisplayName>
        <Description> Multiple spaces in a row that are not used for indentation are typically mistakes. For example: It&apos;s hard to tell, but there are two spaces between foo and ===. Multiple spaces such as this are generally frowned upon in favor of single spaces: Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;Multiple spaces in a row that are not used for indentation are typically mistakes. For example: It’s hard to tell, but there are two spaces between foo and ===. Multiple spaces such as this are generally frowned upon in favor of single spaces: Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{
			"ignoreEOLComments": false,
			"exceptions": {}
		}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMST">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-multi-str</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-multi-str</DisplayName>
        <Description> It&apos;s possible to create multiline strings in JavaScript by using a slash before a newline, such as: Some consider this to be a bad practice as it was an undocumented feature of JavaScript that was only formalized later.</Description>
        <HelpText>&lt;p&gt;It’s possible to create multiline strings in JavaScript by using a slash before a newline, such as: Some consider this to be a bad practice as it was an undocumented feature of JavaScript that was only formalized later.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-new</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-new</DisplayName>
        <Description> The goal of using new with a constructor is typically to create an object of a particular type and store that object in a variable, such as: It&apos;s less common to use new and not store the result, such as: In this case, the created object is thrown away because its reference isn&apos;t stored anywhere, and in many cases, this means that the constructor should be replaced with a function that doesn&apos;t require new to be used.</Description>
        <HelpText>&lt;p&gt;The goal of using new with a constructor is typically to create an object of a particular type and store that object in a variable, such as: It’s less common to use new and not store the result, such as: In this case, the created object is thrown away because its reference isn’t stored anywhere, and in many cases, this means that the constructor should be replaced with a function that doesn’t require new to be used.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NNF">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-new-func</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-new-func</DisplayName>
        <Description> It&apos;s possible to create functions in JavaScript using the Function constructor, such as: This is considered by many to be a bad practice due to the difficult in debugging and reading these types of functions.</Description>
        <HelpText>&lt;p&gt;It’s possible to create functions in JavaScript using the Function constructor, such as: This is considered by many to be a bad practice due to the difficult in debugging and reading these types of functions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NNW">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-new-wrappers</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-new-wrappers</DisplayName>
        <Description> There are three primitive types in JavaScript that have wrapper objects: string, number, and boolean. These are represented by the constructors String, Number, and Boolean, respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods. Behind the scenes, an object of the associated wrapper type is created and then destroyed, which is why you can call methods on primitive values, such as: Behind the scenes in this example, a String object is constructed. The substring() method exists on String.prototype and so is accessible to the string instance. It&apos;s also possible to manually create a new wrapper instance: Although possible, there aren&apos;t any good reasons to use these primitive wrappers as constructors. They tend to confuse other developers more than anything else because they seem like they should act as primitives, but they do not. For example: The first problem is that primitive wrapper objects are, in fact, objects. That means typeof will return &quot;object&quot; instead of &quot;string&quot;, &quot;number&quot;, or &quot;boolean&quot;. The second problem comes with boolean objects. Every object is truthy, that means an instance of Boolean always resolves to true even when its actual value is false. For these reasons, it&apos;s considered a best practice to avoid using primitive wrapper types with new.</Description>
        <HelpText>&lt;p&gt;There are three primitive types in JavaScript that have wrapper objects: string, number, and boolean. These are represented by the constructors String, Number, and Boolean, respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods. Behind the scenes, an object of the associated wrapper type is created and then destroyed, which is why you can call methods on primitive values, such as: Behind the scenes in this example, a String object is constructed. The substring() method exists on String.prototype and so is accessible to the string instance. It’s also possible to manually create a new wrapper instance: Although possible, there aren’t any good reasons to use these primitive wrappers as constructors. They tend to confuse other developers more than anything else because they seem like they should act as primitives, but they do not. For example: The first problem is that primitive wrapper objects are, in fact, objects. That means typeof will return “object” instead of “string”, “number”, or “boolean”. The second problem comes with boolean objects. Every object is truthy, that means an instance of Boolean always resolves to true even when its actual value is false. For these reasons, it’s considered a best practice to avoid using primitive wrapper types with new.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NO">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-octal</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-octal</DisplayName>
        <Description> Octal literals are numerals that begin with a leading zero, such as: The leading zero to identify an octal literal has been a source of confusion and error in JavaScript. ECMAScript 5 deprecates the use of octal numeric literals in JavaScript and octal literals cause syntax errors in strict mode. It&apos;s therefore recommended to avoid using octal literals in JavaScript code.</Description>
        <HelpText>&lt;p&gt;Octal literals are numerals that begin with a leading zero, such as: The leading zero to identify an octal literal has been a source of confusion and error in JavaScript. ECMAScript 5 deprecates the use of octal numeric literals in JavaScript and octal literals cause syntax errors in strict mode. It’s therefore recommended to avoid using octal literals in JavaScript code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NOE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-octal-escape</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-octal-escape</DisplayName>
        <Description> As of version 5 of the ECMAScript specification, octal escape sequences are a deprecated feature and should not be used. It is recommended that Unicode escapes be used instead.</Description>
        <HelpText>&lt;p&gt;As of version 5 of the ECMAScript specification, octal escape sequences are a deprecated feature and should not be used. It is recommended that Unicode escapes be used instead.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-param-reassign</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-param-reassign</DisplayName>
        <Description> Assignment to variables declared as function parameters can be misleading and lead to confusing behavior, as modifying function parameters will also mutate the arguments object. Often, assignment to function parameters is unintended and indicative of a mistake or programmer error.</Description>
        <HelpText>&lt;p&gt;Assignment to variables declared as function parameters can be misleading and lead to confusing behavior, as modifying function parameters will also mutate the arguments object. Often, assignment to function parameters is unintended and indicative of a mistake or programmer error.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{
			"props": false,
			"ignorePropertyModificationsFor": []
		}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  
  <Metric id = "ESLINT_NP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-proto</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-proto</DisplayName>
        <Description> __proto__ property has been deprecated as of ECMAScript 3.1 and shouldn&apos;t be used in the code. Use getPrototypeOf method instead.</Description>
        <HelpText>&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt; property has been deprecated as of ECMAScript 3.1 and shouldn’t be used in the code. Use getPrototypeOf method instead.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NR">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-redeclare</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-redeclare</DisplayName>
        <Description> In JavaScript, it&apos;s possible to redeclare the same variable name using var. This can lead to confusion as to where the variable is actually declared and initialized.</Description>
        <HelpText>&lt;p&gt;In JavaScript, it’s possible to redeclare the same variable name using var. This can lead to confusion as to where the variable is actually declared and initialized.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{
			"builtinGlobals": false
		}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-restricted-properties</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-restricted-properties</DisplayName>
        <Description> Certain properties on objects may be disallowed in a codebase. This is useful for deprecating an API or restricting usage of a module’s methods. For example, you may want to disallow using describe.only when using Mocha or telling people to use Object.assign instead of _.extend.</Description>
        <HelpText>&lt;p&gt;Certain properties on objects may be disallowed in a codebase. This is useful for deprecating an API or restricting usage of a module’s methods. For example, you may want to disallow using describe.only when using Mocha or telling people to use Object.assign instead of _.extend.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true"></Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-return-assign</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-return-assign</DisplayName>
        <Description> One of the interesting, and sometimes confusing, aspects of JavaScript is that assignment can happen at almost any point. Because of this, an errant equals sign can end up causing assignment when the true intent was to do a comparison. This is especially true when using a return statement. For example: It is difficult to tell the intent of the return statement here. It&apos;s possible that the function is meant to return the result of bar + 2, but then why is it assigning to foo? It&apos;s also possible that the intent was to use a comparison operator such as == and that this code is an error. Because of this ambiguity, it&apos;s considered a best practice to not use assignment in return statements.</Description>
        <HelpText>&lt;p&gt;One of the interesting, and sometimes confusing, aspects of JavaScript is that assignment can happen at almost any point. Because of this, an errant equals sign can end up causing assignment when the true intent was to do a comparison. This is especially true when using a return statement. For example: It is difficult to tell the intent of the return statement here. It’s possible that the function is meant to return the result of bar + 2, but then why is it assigning to foo? It’s also possible that the intent was to use a comparison operator such as == and that this code is an error. Because of this ambiguity, it’s considered a best practice to not use assignment in return statements.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-return-await</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-return-await</DisplayName>
        <Description> Inside an async function, return await is useless. Since the return value of an async function is always wrapped in Promise.resolve, return await doesn’t actually do anything except add extra time before the overarching Promise resolves or rejects. This pattern is almost certainly due to programmer ignorance of the return semantics of async functions.</Description>
        <HelpText>&lt;p&gt;Inside an async function, return await is useless. Since the return value of an async function is always wrapped in Promise.resolve, return await doesn’t actually do anything except add extra time before the overarching Promise resolves or rejects. This pattern is almost certainly due to programmer ignorance of the return semantics of async functions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSU">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-script-url</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-script-url</DisplayName>
        <Description> Using javascript: URLs is considered by some as a form of eval. Code passed in javascript: URLs has to be parsed and evaluated by the browser in the same way that eval is processed.</Description>
        <HelpText>&lt;p&gt;Using javascript: URLs is considered by some as a form of eval. Code passed in javascript: URLs has to be parsed and evaluated by the browser in the same way that eval is processed.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSAS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-self-assign</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-self-assign</DisplayName>
        <Description> Self assignments have no effect, so probably those are an error due to incomplete refactoring. Those indicate that what you should do is still remaining.</Description>
        <HelpText>&lt;p&gt;Self assignments have no effect, so probably those are an error due to incomplete refactoring. Those indicate that what you should do is still remaining.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{"props":false}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-self-compare</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-self-compare</DisplayName>
        <Description> Comparing a variable against itself is usually an error, either an typo or refactoring error. It is confusing to the reader and may potentially introduce a runtime error. The only time you would compare a variable against itself is when you are testing for NaN. However, it is far more appropriate to use typeof x === &apos;number&apos; &amp;&amp; isNaN(x) or the Number.isNaN ES2015 function for that use case rather than leaving the reader of the code to determine the intent of self comparison.</Description>
        <HelpText>&lt;p&gt;Comparing a variable against itself is usually an error, either an typo or refactoring error. It is confusing to the reader and may potentially introduce a runtime error. The only time you would compare a variable against itself is when you are testing for NaN. However, it is far more appropriate to use typeof x === ‘number’ &amp;amp;&amp;amp; isNaN(x) or the Number.isNaN ES2015 function for that use case rather than leaving the reader of the code to determine the intent of self comparison.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-sequences</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-sequences</DisplayName>
        <Description> The comma operator includes multiple expressions where only one is expected. It evaluates each operand from left to right and returns the value of the last operand. However, this frequently obscures side effects, and its use is often an accident. Here are some examples of its use:</Description>
        <HelpText>&lt;p&gt;The comma operator includes multiple expressions where only one is expected. It evaluates each operand from left to right and returns the value of the last operand. However, this frequently obscures side effects, and its use is often an accident. Here are some examples of its use:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NTL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-throw-literal</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-throw-literal</DisplayName>
        <Description> It is considered good practice to only throw the Error object itself or an object using the Error object as base objects for user-defined exceptions. The fundamental benefit of Error objects is that they automatically keep track of where they were built and originated. This rule restricts what can be thrown as an exception. When it was first created, it only prevented literals from being thrown (hence the name), but it has now been expanded to only allow expressions which have a possibility of being an Error object.</Description>
        <HelpText>&lt;p&gt;It is considered good practice to only throw the Error object itself or an object using the Error object as base objects for user-defined exceptions. The fundamental benefit of Error objects is that they automatically keep track of where they were built and originated. This rule restricts what can be thrown as an exception. When it was first created, it only prevented literals from being thrown (hence the name), but it has now been expanded to only allow expressions which have a possibility of being an Error object.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NULC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-unmodified-loop-condition</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unmodified-loop-condition</DisplayName>
        <Description> Variables in a loop condition often are modified in the loop. If not, it’s possibly a mistake.</Description>
        <HelpText>&lt;p&gt;Variables in a loop condition often are modified in the loop. If not, it’s possibly a mistake.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-unused-expressions</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unused-expressions</DisplayName>
        <Description> Unused expressions are those expressions that evaluate to a value but are never used. For example: This string is a valid JavaScript expression, but isn&apos;t actually used. Even though it&apos;s not a syntax error it is clearly a logic error and it has no effect on the code being executed.</Description>
        <HelpText>&lt;p&gt;Unused expressions are those expressions that evaluate to a value but are never used. For example: This string is a valid JavaScript expression, but isn’t actually used. Even though it’s not a syntax error it is clearly a logic error and it has no effect on the code being executed.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">{
			"allowShortCircuit": false,
			"allowTernary": false,
			"allowTaggedTemplates": false
		}</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NULA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-unused-labels</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unused-labels</DisplayName>
        <Description> The --fix option on the command line can automatically fix some of the problems reported by this rule. Labels that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring.</Description>
        <HelpText>&lt;p&gt;The --fix option on the command line can automatically fix some of the problems reported by this rule. Labels that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-useless-call</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-useless-call</DisplayName>
        <Description> The function invocation can be written by Function.prototype.call() and Function.prototype.apply(). But Function.prototype.call() and Function.prototype.apply() are slower than the normal function invocation.</Description>
        <HelpText>&lt;p&gt;The function invocation can be written by Function.prototype.call() and Function.prototype.apply(). But Function.prototype.call() and Function.prototype.apply() are slower than the normal function invocation.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUCO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-useless-concat</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-useless-concat</DisplayName>
        <Description> It&apos;s unnecessary to concatenate two strings together, such as: This code is likely the result of refactoring where a variable was removed from the concatenation (such as &quot;a&quot; + b + &quot;b&quot;). In such a case, the concatenation isn&apos;t important and the code can be rewritten as:</Description>
        <HelpText>&lt;p&gt;It’s unnecessary to concatenate two strings together, such as: This code is likely the result of refactoring where a variable was removed from the concatenation (such as “a” + b + “b”). In such a case, the concatenation isn’t important and the code can be rewritten as:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUES">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-useless-escape</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-useless-escape</DisplayName>
        <Description> Escaping non-special characters in strings, template literals, and regular expressions doesn’t have any effect, as demonstrated in the following example:</Description>
        <HelpText>&lt;p&gt;Escaping non-special characters in strings, template literals, and regular expressions doesn’t have any effect, as demonstrated in the following example:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NURE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-useless-return</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-useless-return</DisplayName>
        <Description> A return; statement with nothing after it is redundant, and has no effect on the runtime behavior of a function. This can be confusing, so it’s better to disallow these redundant statements.</Description>
        <HelpText>&lt;p&gt;A return; statement with nothing after it is redundant, and has no effect on the runtime behavior of a function. This can be confusing, so it’s better to disallow these redundant statements.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NV">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-void</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-void</DisplayName>
        <Description> The void operator takes an operand and returns undefined: void expression will evaluate expression and return undefined. It can be used to ignore any side effects expression may produce: The common case of using void operator is to get a &quot;pure&quot; undefined value as prior to ES5 the undefined variable was mutable: Another common case is to minify code as void 0 is shorter than undefined: When used with IIFE (immediately-invoked function expression) void can be used to force the function keyword to be treated as an expression instead of a declaration: Some code styles prohibit void operator marking it as non-obvious and hard to read.</Description>
        <HelpText>&lt;p&gt;The void operator takes an operand and returns undefined: void expression will evaluate expression and return undefined. It can be used to ignore any side effects expression may produce: The common case of using void operator is to get a “pure” undefined value as prior to ES5 the undefined variable was mutable: Another common case is to minify code as void 0 is shorter than undefined: When used with IIFE (immediately-invoked function expression) void can be used to force the function keyword to be treated as an expression instead of a declaration: Some code styles prohibit void operator marking it as non-obvious and hard to read.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NWC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-warning-comments</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-warning-comments</DisplayName>
        <Description> Often code is marked during development process for later work on it or with additional thoughts. Examples are typically // TODO: do something or // FIXME: this is not a good idea. These comments are a warning signal, that there is something not production ready in your code. Most likely you want to fix it or remove the comments before you roll out your code with a good feeling.</Description>
        <HelpText>&lt;p&gt;Often code is marked during development process for later work on it or with additional thoughts. Examples are typically // TODO: do something or // FIXME: this is not a good idea. These comments are a warning signal, that there is something not production ready in your code. Most likely you want to fix it or remove the comments before you roll out your code with a good feeling.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "terms": [ "todo", "fixme", "xxx" ],
                "location": "start"
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NW">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-with</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-with</DisplayName>
        <Description> The with statement is potentially problematic because it adds members of an object to the current scope, making it impossible to tell what a variable inside the block actually refers to. Additionally, the with statement cannot be used in strict mode.</Description>
        <HelpText>&lt;p&gt;The with statement is potentially problematic because it adds members of an object to the current scope, making it impossible to tell what a variable inside the block actually refers to. Additionally, the with statement cannot be used in strict mode.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_PPRE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>prefer-promise-reject-errors</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>prefer-promise-reject-errors</DisplayName>
        <Description> It is considered good practice to only pass instances of the built-in Error object to the reject() function for user-defined errors in Promises. Error objects automatically store a stack trace, which can be used to debug an error by determining where it came from. If a Promise is rejected with a non-Error value, it can be difficult to determine where the rejection occurred.</Description>
        <HelpText>&lt;p&gt;It is considered good practice to only pass instances of the built-in Error object to the reject() function for user-defined errors in Promises. Error objects automatically store a stack trace, which can be used to debug an error by determining where it came from. If a Promise is rejected with a non-Error value, it can be difficult to determine where the rejection occurred.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_R">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>radix</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>radix</DisplayName>
        <Description> When using the parseInt() function it is common to omit the second argument, the radix, and let the function try to determine from the first argument what type of number it is. By default, parseInt() will autodetect decimal and hexadecimal (via 0x prefix). Prior to ECMAScript 5, parseInt() also autodetected octal literals, which caused problems because many developers assumed a leading 0 would be ignored. This confusion led to the suggestion that you always use the radix parameter to parseInt() to eliminate unintended consequences. So instead of doing this: Do this: ECMAScript 5 changed the behavior of parseInt() so that it no longer autodetects octal literals and instead treats them as decimal literals. However, the differences between hexadecimal and decimal interpretation of the first parameter causes many developers to continue using the radix parameter to ensure the string is interpreted in the intended way. On the other hand, if the code is targeting only ES5-compliant environments passing the radix 10 may be redundant. In such a case you might want to disallow using such a radix.</Description>
        <HelpText>&lt;p&gt;When using the parseInt() function it is common to omit the second argument, the radix, and let the function try to determine from the first argument what type of number it is. By default, parseInt() will autodetect decimal and hexadecimal (via 0x prefix). Prior to ECMAScript 5, parseInt() also autodetected octal literals, which caused problems because many developers assumed a leading 0 would be ignored. This confusion led to the suggestion that you always use the radix parameter to parseInt() to eliminate unintended consequences. So instead of doing this: Do this: ECMAScript 5 changed the behavior of parseInt() so that it no longer autodetects octal literals and instead treats them as decimal literals. However, the differences between hexadecimal and decimal interpretation of the first parameter causes many developers to continue using the radix parameter to ensure the string is interpreted in the intended way. On the other hand, if the code is targeting only ES5-compliant environments passing the radix 10 may be redundant. In such a case you might want to disallow using such a radix.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_RA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>require-await</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>require-await</DisplayName>
        <Description> Async functions which have no await expression may be the unintentional result of refactoring.</Description>
        <HelpText>&lt;p&gt;Async functions which have no await expression may be the unintentional result of refactoring.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_VOT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>vars-on-top</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>vars-on-top</DisplayName>
        <Description> The vars-on-top rule generates warnings when variable declarations are not used serially at the top of a function scope or the top of a program. By default variable declarations are always moved (“hoisted”) invisibly to the top of their containing scope by the JavaScript interpreter. This rule forces the programmer to represent that behaviour by manually moving the variable declaration to the top of its containing scope.</Description>
        <HelpText>&lt;p&gt;The vars-on-top rule generates warnings when variable declarations are not used serially at the top of a function scope or the top of a program. By default variable declarations are always moved (“hoisted”) invisibly to the top of their containing scope by the JavaScript interpreter. This rule forces the programmer to represent that behaviour by manually moving the variable declaration to the top of its containing scope.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_WI">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>wrap-iife</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>wrap-iife</DisplayName>
        <Description> Require immediate function invocation to be wrapped in parentheses.</Description>
        <HelpText>&lt;p&gt;Require immediate function invocation to be wrapped in parentheses.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
		<Setting name = "__eslint_param__" editable = "true">"outside"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_Y">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>yoda</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>yoda</DisplayName>
        <Description> Yoda conditions are so named because the literal value of the condition comes first while the variable comes second. For example, the following is a Yoda condition: This is called a Yoda condition because it reads as, &quot;red is the color&quot;, similar to the way the Star Wars character Yoda speaks. Compare to the other way of arranging the operands: This typically reads, &quot;color is red&quot;, which is arguably a more natural way to describe the comparison. Proponents of Yoda conditions highlight that it is impossible to mistakenly use = instead of == because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available. Opponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of = instead of == (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn&apos;t outweigh the readability hit the code takes while using Yoda conditions.</Description>
        <HelpText>&lt;p&gt;Yoda conditions are so named because the literal value of the condition comes first while the variable comes second. For example, the following is a Yoda condition: This is called a Yoda condition because it reads as, “red is the color”, similar to the way the Star Wars character Yoda speaks. Compare to the other way of arranging the operands: This typically reads, “color is red”, which is arguably a more natural way to describe the comparison. Proponents of Yoda conditions highlight that it is impossible to mistakenly use = instead of == because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available. Opponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of = instead of == (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn’t outweigh the readability hit the code takes while using Yoda conditions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"never"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
<!-- ============================== -->
<!-- END OF Best Practices category -->
<!-- ============================== -->




<!-- =========================== -->
<!-- Strict Mode category -->
<!-- =========================== -->

<Metric id = "ESLINT_S">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>strict</OriginalId>
      <GroupMember>Strict Mode</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>strict</DisplayName>
        <Description> A Use Strict Directive at the beginning of a script or function body enables strict mode semantics: When used globally, as in the preceding example, the entire script, including all contained functions, are strict mode code. It is also possible to specify function-level strict mode, such that strict mode applies only to the function in which the directive occurs:</Description>
        <HelpText>&lt;p&gt;A Use Strict Directive at the beginning of a script or function body enables strict mode semantics: When used globally, as in the preceding example, the entire script, including all contained functions, are strict mode code. It is also possible to specify function-level strict mode, such that strict mode applies only to the function in which the directive occurs:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"safe"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>

<!-- ====================== -->
<!-- END OF Strict Mode category -->
<!-- ====================== -->



<!-- =========================== -->
<!-- Variables category -->
<!-- =========================== -->

<Metric id = "ESLINT_ID">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>init-declarations</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>init-declarations</DisplayName>
        <Description> In JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, foo is initialized during declaration, while bar is initialized later.</Description>
        <HelpText>&lt;p&gt;In JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, foo is initialized during declaration, while bar is initialized later.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "ignoreForLoopInit": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-catch-shadow</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-catch-shadow</DisplayName>
        <Description> In IE 8 and earlier, the catch clause parameter can overwrite the value of a variable in the outer scope, if that variable has the same name as the catch clause parameter.</Description>
        <HelpText>&lt;p&gt;In IE 8 and earlier, the catch clause parameter can overwrite the value of a variable in the outer scope, if that variable has the same name as the catch clause parameter.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NDV">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-delete-var</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-delete-var</DisplayName>
        <Description> The purpose of the delete operator is to remove a property from an object. Using the delete operator on a variable might lead to unexpected behavior.</Description>
        <HelpText>&lt;p&gt;The purpose of the delete operator is to remove a property from an object. Using the delete operator on a variable might lead to unexpected behavior.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NLV">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-label-var</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-label-var</DisplayName>
        <Description> This rule aims to create clearer code by disallowing the bad practice of creating a label that shares a name with a variable that is in scope.</Description>
        <HelpText>&lt;p&gt;This rule aims to create clearer code by disallowing the bad practice of creating a label that shares a name with a variable that is in scope.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRG">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-restricted-globals</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-restricted-globals</DisplayName>
        <Description> Disallowing usage of specific global variables can be useful if you want to allow a set of global variables by enabling an environment, but still want to disallow some of those.</Description>
        <HelpText>&lt;p&gt;Disallowing usage of specific global variables can be useful if you want to allow a set of global variables by enabling an environment, but still want to disallow some of those.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"event"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSH">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-shadow</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-shadow</DisplayName>
        <Description> Shadowing is the process by which a local variable shares the same name as a variable in its containing scope. For example: In this case, the variable a inside of b() is shadowing the variable a in the global scope. This can cause confusion while reading the code and it&apos;s impossible to access the global variable.</Description>
        <HelpText>&lt;p&gt;Shadowing is the process by which a local variable shares the same name as a variable in its containing scope. For example: In this case, the variable a inside of b() is shadowing the variable a in the global scope. This can cause confusion while reading the code and it’s impossible to access the global variable.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "Priority" editable = "true">
        {
            "builtinGlobals": false,
            "hoist": "functions",
            "allow": []
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSRN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-shadow-restricted-names</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-shadow-restricted-names</DisplayName>
        <Description> ES5 §15.1.1 Value Properties of the Global Object (NaN, Infinity, undefined) as well as strict mode restricted identifiers eval and arguments are considered to be restricted names in JavaScript. Defining them to mean something else can have unintended consequences and confuse others reading the code. For example, there&apos;s nothing prevent you from writing: Then any code used within the same scope would not get the global undefined, but rather the local version with a very different meaning.</Description>
        <HelpText>&lt;p&gt;ES5 §15.1.1 Value Properties of the Global Object (NaN, Infinity, undefined) as well as strict mode restricted identifiers eval and arguments are considered to be restricted names in JavaScript. Defining them to mean something else can have unintended consequences and confuse others reading the code. For example, there’s nothing prevent you from writing: Then any code used within the same scope would not get the global undefined, but rather the local version with a very different meaning.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUN">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-undef</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-undef</DisplayName>
        <Description>This rule can help you locate potential ReferenceErrors resulting from misspellings of variable and parameter names, or accidental implicit globals (for example, from forgetting the var keyword in a for loop initializer).</Description>
        <HelpText>&lt;p&gt;This rule can help you locate potential ReferenceErrors resulting from misspellings of variable and parameter names, or accidental implicit globals (for example, from forgetting the var keyword in a for loop initializer).&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "typeof": false }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUI">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-undef-init</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-undef-init</DisplayName>
        <Description> In JavaScript, a variable that is declared and not initialized to any value automatically gets the value of undefined. For example: It&apos;s therefore unnecessary to initialize a variable to undefined, such as: It&apos;s considered a best practice to avoid initializing variables to undefined.</Description>
        <HelpText>&lt;p&gt;In JavaScript, a variable that is declared and not initialized to any value automatically gets the value of undefined. For example: It’s therefore unnecessary to initialize a variable to undefined, such as: It’s considered a best practice to avoid initializing variables to undefined.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUND">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-undefined</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-undefined</DisplayName>
        <Description> The undefined variable is unique in JavaScript because it is actually a property of the global object. As such, in ECMAScript 3 it was possible to overwrite the value of undefined. While ECMAScript 5 disallows overwriting undefined, it&apos;s still possible to shadow undefined, such as: This represents a problem for undefined that doesn&apos;t exist for null, which is a keyword and primitive value that can neither be overwritten nor shadowed. All uninitialized variables automatically get the value of undefined: For this reason, it&apos;s not necessary to explicitly initialize a variable to undefined. Taking all of this into account, some style guides forbid the use of undefined, recommending instead:</Description>
        <HelpText>&lt;p&gt;The undefined variable is unique in JavaScript because it is actually a property of the global object. As such, in ECMAScript 3 it was possible to overwrite the value of undefined. While ECMAScript 5 disallows overwriting undefined, it’s still possible to shadow undefined, such as: This represents a problem for undefined that doesn’t exist for null, which is a keyword and primitive value that can neither be overwritten nor shadowed. All uninitialized variables automatically get the value of undefined: For this reason, it’s not necessary to explicitly initialize a variable to undefined. Taking all of this into account, some style guides forbid the use of undefined, recommending instead:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUV">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-unused-vars</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unused-vars</DisplayName>
        <Description> Variables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers.</Description>
        <HelpText>&lt;p&gt;Variables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
			"vars": "all",
			"args": "after-used"
		}
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUBD">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-use-before-define</OriginalId>
      <GroupMember>Variables</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-use-before-define</DisplayName>
        <Description> In JavaScript, prior to ES6, variable and function declarations are hoisted to the top of a scope, so it&apos;s possible to use identifiers before their formal declarations in code. This can be confusing and some believe it is best to always declare variables and functions before using them. In ES6, block-level bindings (let and const) introduce a &quot;temporal dead zone&quot; where a ReferenceError will be thrown with any attempt to access the variable before its declaration.</Description>
        <HelpText>&lt;p&gt;In JavaScript, prior to ES6, variable and function declarations are hoisted to the top of a scope, so it’s possible to use identifiers before their formal declarations in code. This can be confusing and some believe it is best to always declare variables and functions before using them. In ES6, block-level bindings (let and const) introduce a “temporal dead zone” where a ReferenceError will be thrown with any attempt to access the variable before its declaration.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "functions": true,
            "classes": true,
            "variables": true
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
<!-- ============================== -->
<!-- END OF Variables category -->
<!-- ============================== -->



<!-- ============================ -->
<!-- NodeJS and CommonJS category -->
<!-- ============================ -->

<Metric id = "ESLINT_CRE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>callback-return</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>callback-return</DisplayName>
        <Description> The callback pattern is at the heart of most I/O and event-driven programming in JavaScript. To prevent calling the callback multiple times it is important to return anytime the callback is triggered outside of the main function body. Neglecting this technique often leads to issues where you do something more than once. For example, in the case of an HTTP request, you may try to send HTTP headers more than once leading node.js to throw a Can&apos;t render headers after they are sent to the client. error.</Description>
        <HelpText>&lt;p&gt;The callback pattern is at the heart of most I/O and event-driven programming in JavaScript. To prevent calling the callback multiple times it is important to return anytime the callback is triggered outside of the main function body. Neglecting this technique often leads to issues where you do something more than once. For example, in the case of an HTTP request, you may try to send HTTP headers more than once leading node.js to throw a Can’t render headers after they are sent to the client. error.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_GR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>global-require</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>global-require</DisplayName>
        <Description> In Node.js, module dependencies are included using the require() function, such as: While require() may be called anywhere in code, some style guide prescribe that it should be called only in the top-level scope of a module to make it easier to identify dependencies. For instance, it&apos;s arguably harder to identify dependencies when they are deeply nested inside of functions and other statements: Since require() does a synchronous load, it can cause performance problems when used in other locations.</Description>
        <HelpText>&lt;p&gt;In Node.js, module dependencies are included using the require() function, such as: While require() may be called anywhere in code, some style guide prescribe that it should be called only in the top-level scope of a module to make it easier to identify dependencies. For instance, it’s arguably harder to identify dependencies when they are deeply nested inside of functions and other statements: Since require() does a synchronous load, it can cause performance problems when used in other locations.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_HCE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>handle-callback-err</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>handle-callback-err</DisplayName>
        <Description> In node, a common pattern for dealing with asynchronous behavior is called the callback pattern. This pattern expects an Error object or null as the first argument of the callback. Forgetting to handle these errors can lead to some really strange behavior in your application.</Description>
        <HelpText>&lt;p&gt;In node, a common pattern for dealing with asynchronous behavior is called the callback pattern. This pattern expects an Error object or null as the first argument of the callback. Forgetting to handle these errors can lead to some really strange behavior in your application.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"err"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NBC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-buffer-constructor</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-buffer-constructor</DisplayName>
        <Description> In Node.js, the behavior of the Buffer constructor is different depending on the type of its argument. Passing an argument from user input to Buffer() without validating its type can lead to security vulnerabilities such as remote memory disclosure and denial of service. As a result, the Buffer constructor has been deprecated and should not be used. Use the producer methods Buffer.from, Buffer.alloc, and Buffer.allocUnsafe instead.</Description>
        <HelpText>&lt;p&gt;In Node.js, the behavior of the Buffer constructor is different depending on the type of its argument. Passing an argument from user input to Buffer() without validating its type can lead to security vulnerabilities such as remote memory disclosure and denial of service. As a result, the Buffer constructor has been deprecated and should not be used. Use the producer methods Buffer.from, Buffer.alloc, and Buffer.allocUnsafe instead.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"err"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-mixed-requires</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-mixed-requires</DisplayName>
        <Description> In the Node.JS community it is often customary to separate the required modules from other variable declarations, sometimes also grouping them by their type. This rule helps you enforce this convention.</Description>
        <HelpText>&lt;p&gt;In the Node.JS community it is often customary to separate the required modules from other variable declarations, sometimes also grouping them by their type. This rule helps you enforce this convention.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "grouping": false, "allowCall": false }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NNRE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-new-require</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-new-require</DisplayName>
        <Description> The require function is used to include modules that exist in separate files, such as: Some modules return a constructor which can potentially lead to code such as: Unfortunately, this introduces a high potential for confusion since the code author likely meant to write: For this reason, it is usually best to disallow this particular expression.</Description>
        <HelpText>&lt;p&gt;The require function is used to include modules that exist in separate files, such as: Some modules return a constructor which can potentially lead to code such as: Unfortunately, this introduces a high potential for confusion since the code author likely meant to write: For this reason, it is usually best to disallow this particular expression.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-path-concat</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-path-concat</DisplayName>
        <Description> In Node.js, the __dirname and __filename global variables contain the directory path and the file path of the currently executing script file, respectively. Sometimes, developers try to use these variables to create paths to other files, such as: However, there are a few problems with this. First, you can&apos;t be sure what type of system the script is running on. Node.js can be run on any computer, including Windows, which uses a different path separator. It&apos;s very easy, therefore, to create an invalid path using string concatenation and assuming Unix-style separators. There&apos;s also the possibility of having double separators, or otherwise ending up with an invalid path. In order to avoid any confusion as to how to create the correct path, Node.js provides the path module. This module uses system-specific information to always return the correct value. So you can rewrite the previous example as: This example doesn&apos;t need to include separators as path.join() will do it in the most appropriate manner. Alternately, you can use path.resolve() to retrieve the fully-qualified path: Both path.join() and path.resolve() are suitable replacements for string concatenation wherever file or directory paths are being created.</Description>
        <HelpText>&lt;p&gt;In Node.js, the __dirname and __filename global variables contain the directory path and the file path of the currently executing script file, respectively. Sometimes, developers try to use these variables to create paths to other files, such as: However, there are a few problems with this. First, you can’t be sure what type of system the script is running on. Node.js can be run on any computer, including Windows, which uses a different path separator. It’s very easy, therefore, to create an invalid path using string concatenation and assuming Unix-style separators. There’s also the possibility of having double separators, or otherwise ending up with an invalid path. In order to avoid any confusion as to how to create the correct path, Node.js provides the path module. This module uses system-specific information to always return the correct value. So you can rewrite the previous example as: This example doesn’t need to include separators as path.join() will do it in the most appropriate manner. Alternately, you can use path.resolve() to retrieve the fully-qualified path: Both path.join() and path.resolve() are suitable replacements for string concatenation wherever file or directory paths are being created.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-process-env</OriginalId>
      <GroupMember>Best Practices</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-process-env</DisplayName>
        <Description>The process.env object in Node.js is used to store deployment/configuration parameters. Littering it through out a project could lead to maintenance issues as it&apos;s another kind of global dependency. As such, it could lead to merge conflicts in a multi-user setup and deployment issues in a multi-server setup. Instead, one of the best practices is to define all those parameters in a single configuration/settings file which could be accessed throughout the project.</Description>
        <HelpText>&lt;p&gt;The process.env object in Node.js is used to store deployment/configuration parameters. Littering it through out a project could lead to maintenance issues as it’s another kind of global dependency. As such, it could lead to merge conflicts in a multi-user setup and deployment issues in a multi-server setup. Instead, one of the best practices is to define all those parameters in a single configuration/settings file which could be accessed throughout the project.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPEX">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-process-exit</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-process-exit</DisplayName>
        <Description> The process.exit() method in Node.js is used to immediately stop the Node.js process and exit. This is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. For example: This code could appear in any module and will stop the entire application when somethingBadHappened is truthy. This doesn&apos;t give the application any chance to respond to the error. It&apos;s usually better to throw an error and allow the application to handle it appropriately: By throwing an error in this way, other parts of the application have an opportunity to handle the error rather than stopping the application altogether. If the error bubbles all the way up to the process without being handled, then the process will exit and a non-zero exit code will returned, so the end result is the same.</Description>
        <HelpText>&lt;p&gt;The process.exit() method in Node.js is used to immediately stop the Node.js process and exit. This is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. For example: This code could appear in any module and will stop the entire application when somethingBadHappened is truthy. This doesn’t give the application any chance to respond to the error. It’s usually better to throw an error and allow the application to handle it appropriately: By throwing an error in this way, other parts of the application have an opportunity to handle the error rather than stopping the application altogether. If the error bubbles all the way up to the process without being handled, then the process will exit and a non-zero exit code will returned, so the end result is the same.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRM">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-restricted-modules</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-restricted-modules</DisplayName>
        <Description> Disallowing usage of specific node modules can be useful if you want to control the available methods, a developer can use, to implement a feature. This way you can block usage of the fs module if you want disallow file system access. Blocking the os module can be useful if you don&apos;t want to allow any operating system specific code.</Description>
        <HelpText>&lt;p&gt;Disallowing usage of specific node modules can be useful if you want to control the available methods, a developer can use, to implement a feature. This way you can block usage of the fs module if you want disallow file system access. Blocking the os module can be useful if you don’t want to allow any operating system specific code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "paths": [] }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSY">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-sync</OriginalId>
      <GroupMember>Node.js and CommonJS</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-sync</DisplayName>
        <Description> In Node.js, most I/O is done through asynchronous methods. However, there are often synchronous versions of the asynchronous methods. For example, fs.exists() and fs.existsSync(). In some contexts, using synchronous operations is okay (if, as with ESLint, you are writing a command line utility). However, in other contexts the use of synchronous operations is considered a bad practice that should be avoided. For example, if you are running a high-travel web server on Node.js, you should consider carefully if you want to allow any synchronous operations that could lock up the server.</Description>
        <HelpText>&lt;p&gt;In Node.js, most I/O is done through asynchronous methods. However, there are often synchronous versions of the asynchronous methods. For example, fs.exists() and fs.existsSync(). In some contexts, using synchronous operations is okay (if, as with ESLint, you are writing a command line utility). However, in other contexts the use of synchronous operations is considered a bad practice that should be avoided. For example, if you are running a high-travel web server on Node.js, you should consider carefully if you want to allow any synchronous operations that could lock up the server.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "allowAtRootLevel": false }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
<!-- =================================== -->
<!-- END OF NodeJS and CommonJS category -->
<!-- =================================== -->


<!-- ========================= -->
<!-- Stylistic Issues category -->
<!-- ========================= -->

<Metric id = "ESLINT_ABN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>array-bracket-newline</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>array-bracket-newline</DisplayName>
        <Description>A number of style guides require or disallow line breaks inside of array brackets.</Description>
        <HelpText>&lt;p&gt;A number of style guides require or disallow line breaks inside of array brackets.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            { "multiline": true, "minItems": 2 }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_ABS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>array-bracket-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>array-bracket-spacing</DisplayName>
        <Description>A number of style guides require or disallow spaces between array brackets and other tokens. This rule applies to both array literals and destructuring assignments (ECMAScript 6).</Description>
        <HelpText>&lt;p&gt;A number of style guides require or disallow spaces between array brackets and other tokens. This rule applies to both array literals and destructuring assignments (ECMAScript 6).&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            "always"
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_AEN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>array-element-newline</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>array-element-newline</DisplayName>
        <Description>A number of style guides require or disallow line breaks between array elements.</Description>
        <HelpText>&lt;p&gt;A number of style guides require or disallow line breaks between array elements.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            "always"
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_BS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>block-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>block-spacing</DisplayName>
        <Description> This rule is for spacing style within single line blocks. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;This rule is for spacing style within single line blocks. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_BST">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>brace-style</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>brace-style</DisplayName>
        <Description> Brace style is closely related to indent style in programming and describes the placement of curly braces relative to their control statement and body. There are probably a dozen, if not more, brace styles in the world. The one true brace style is one of the most common brace styles in JavaScript, in which the opening curly brace of a block is placed on the same line as its corresponding statement or declaration. For example: One common variant of one true brace style is called Stroustrup, in which the else statements in an if-else construct, as well as catch and finally, must be on its own line after the preceding closing brace, as in this example: Another style is called Allman, in which all the braces are expected to be on their own lines without any extra indentation: While no style is considered better than the other, most developers agree that having a consistent style throughout a project is important for its long-term maintainability.</Description>
        <HelpText>&lt;p&gt;Brace style is closely related to indent style in programming and describes the placement of curly braces relative to their control statement and body. There are probably a dozen, if not more, brace styles in the world. The one true brace style is one of the most common brace styles in JavaScript, in which the opening curly brace of a block is placed on the same line as its corresponding statement or declaration. For example: One common variant of one true brace style is called Stroustrup, in which the else statements in an if-else construct, as well as catch and finally, must be on its own line after the preceding closing brace, as in this example: Another style is called Allman, in which all the braces are expected to be on their own lines without any extra indentation: While no style is considered better than the other, most developers agree that having a consistent style throughout a project is important for its long-term maintainability.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"1tbs"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>camelcase</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>camelcase</DisplayName>
        <Description> When it comes to naming variables, styleguides generally fall into one of two camps: camelcase (variableName) and underscores (variable_name). This rule focuses on using the camelcase approach. If your styleguide calls for camelcasing your variable names, then this rule is for you!</Description>
        <HelpText>&lt;p&gt;When it comes to naming variables, styleguides generally fall into one of two camps: camelcase (variableName) and underscores (variable_name). This rule focuses on using the camelcase approach. If your styleguide calls for camelcasing your variable names, then this rule is for you!&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "properties": "always" }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>capitalized-comments</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>capitalized-comments</DisplayName>
        <Description>Comments are useful for leaving information for future developers. In order for that information to be useful and not distracting, it is sometimes desirable for comments to follow a particular style. One element of comment formatting styles is whether the first word of a comment should be capitalized or lowercase. In general, no comment style is any more or less valid than any others, but many developers would agree that a consistent style can improve a project’s maintainability.</Description>
        <HelpText>&lt;p&gt;Comments are useful for leaving information for future developers. In order for that information to be useful and not distracting, it is sometimes desirable for comments to follow a particular style. One element of comment formatting styles is whether the first word of a comment should be capitalized or lowercase. In general, no comment style is any more or less valid than any others, but many developers would agree that a consistent style can improve a project’s maintainability.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  
  <Metric id = "ESLINT_CD">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>comma-dangle</OriginalId>
      <GroupMember>Possible Errors</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>comma-dangle</DisplayName>
        <Description> Trailing commas in object literals are valid according to the ECMAScript 5 (and ECMAScript 3!) spec. However, IE8 (when not in IE8 document mode) and below will throw an error when it encounters trailing commas in JavaScript. On the other hand, trailing commas simplify adding and removing items to objects and arrays, since only the lines you are modifying must be touched.</Description>
        <HelpText>&lt;p&gt;Trailing commas in object literals are valid according to the ECMAScript 5 (and ECMAScript 3!) spec. However, IE8 (when not in IE8 document mode) and below will throw an error when it encounters trailing commas in JavaScript. On the other hand, trailing commas simplify adding and removing items to objects and arrays, since only the lines you are modifying must be touched.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "arrays": "never",
                "objects": "never",
                "imports": "never",
                "exports": "never",
                "functions": "ignore"
            }
      </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>comma-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>comma-spacing</DisplayName>
        <Description>Spacing around commas improve readability of a list of items. Although most of the style guidelines for languages prescribe adding a space after a comma and not before it, it is subjective to the preferences of a project.</Description>
        <HelpText>&lt;p&gt;Spacing around commas improve readability of a list of items. Although most of the style guidelines for languages prescribe adding a space after a comma and not before it, it is subjective to the preferences of a project.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "before": false,
            "after": true
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CST">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>comma-style</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>comma-style</DisplayName>
        <Description> Comma Style rule enforces comma styles for a list of things separated by commas. There are two comma styles primarily in JavaScript. The standard one in which commas are placed at the end of the line. And Comma-First, in which, commas are placed at the start of the next line after the list item. One of the justifications for using Comma-First is that it helps tracking missing and trailing commas. In case linting is turned off, missing commas in variable declarations lead to leakage of global variables and trailing commas lead to errors in older versions of IE.</Description>
        <HelpText>&lt;p&gt;Comma Style rule enforces comma styles for a list of things separated by commas. There are two comma styles primarily in JavaScript. The standard one in which commas are placed at the end of the line. And Comma-First, in which, commas are placed at the start of the next line after the list item. One of the justifications for using Comma-First is that it helps tracking missing and trailing commas. In case linting is turned off, missing commas in variable declarations lead to leakage of global variables and trailing commas lead to errors in older versions of IE.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"last"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CPS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>computed-property-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>computed-property-spacing</DisplayName>
        <Description> While formatting preferences are very personal, a number of style guides require or disallow spaces between computed properties in the following situations: Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;While formatting preferences are very personal, a number of style guides require or disallow spaces between computed properties in the following situations: Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_CT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>consistent-this</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>consistent-this</DisplayName>
        <Description> It is often necessary to capture the current execution context in order to make it available subsequently. A prominent example of this are jQuery callbacks: There are many commonly used aliases for this such as self, that or me. It is desirable to ensure that whichever alias the team agrees upon is used consistently throughout the application.</Description>
        <HelpText>&lt;p&gt;It is often necessary to capture the current execution context in order to make it available subsequently. A prominent example of this are jQuery callbacks: There are many commonly used aliases for this such as self, that or me. It is desirable to ensure that whichever alias the team agrees upon is used consistently throughout the application.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"that"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_EL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>eol-last</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>eol-last</DisplayName>
        <Description>Trailing newlines in non-empty files are a common UNIX idiom. Benefits of trailing newlines include the ability to concatenate or append to files as well as output files to the terminal without interfering with shell prompts.</Description>
        <HelpText>&lt;p&gt;Trailing newlines in non-empty files are a common UNIX idiom. Benefits of trailing newlines include the ability to concatenate or append to files as well as output files to the terminal without interfering with shell prompts.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_FCS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>func-call-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>func-call-spacing</DisplayName>
        <Description>When calling a function, developers may insert optional whitespace between the function’s name and the parentheses that invoke it.</Description>
        <HelpText>&lt;p&gt;When calling a function, developers may insert optional whitespace between the function’s name and the parentheses that invoke it.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"never"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_FNM">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>func-name-matching</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>func-name-matching</DisplayName>
        <Description>This rule requires function names to match the name of the variable or property to which they are assigned. The rule will ignore property assignments where the property name is a literal that is not a valid identifier in the ECMAScript version specified in your configuration (default ES5).</Description>
        <HelpText>&lt;p&gt;This rule requires function names to match the name of the variable or property to which they are assigned. The rule will ignore property assignments where the property name is a literal that is not a valid identifier in the ECMAScript version specified in your configuration (default ES5).&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_FN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>func-names</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>func-names</DisplayName>
        <Description> A pattern that&apos;s becoming more common is to give function expressions names to aid in debugging, such as: Adding the second bar in the above example is optional. If you leave off the function name then when the function throws an exception you are likely to get something similar to anonymous function in the stack trace. If you provide the optional name for a function expression then you will get the name of the function expression in the stack trace.</Description>
        <HelpText>&lt;p&gt;A pattern that’s becoming more common is to give function expressions names to aid in debugging, such as: Adding the second bar in the above example is optional. If you leave off the function name then when the function throws an exception you are likely to get something similar to anonymous function in the stack trace. If you provide the optional name for a function expression then you will get the name of the function expression in the stack trace.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_FS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>func-style</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>func-style</DisplayName>
        <Description> There are two ways of defining functions in JavaScript: function declarations and function expressions. Declarations have the function keyword first, followed by a name, followed by its arguments and the function body, such as: Equivalent function expressions begin with the var keyword, followed by a name, and then the function itself, such as: The primary difference between function declarations and function expressions is that declarations are hoisted to the top of the scope in which they are defined, which allows you to write code that uses the function before the declaration. For example: Although this code might seem like an error, it actually works fine because JavaScript engines hoist the function declarations to the top of the scope. That means this code is treated as if the declaration came before the invocation. For function expressions, you must define the function before it is used, otherwise it causes an error. Example: In this case, doSomething() is undefined at the time of invocation and so causes a runtime error. Due to these different behaviors, it is common to have guidelines as to which style of function should be used. There is really no correct or incorrect choice here, it is just a preference.</Description>
        <HelpText>&lt;p&gt;There are two ways of defining functions in JavaScript: function declarations and function expressions. Declarations have the function keyword first, followed by a name, followed by its arguments and the function body, such as: Equivalent function expressions begin with the var keyword, followed by a name, and then the function itself, such as: The primary difference between function declarations and function expressions is that declarations are hoisted to the top of the scope in which they are defined, which allows you to write code that uses the function before the declaration. For example: Although this code might seem like an error, it actually works fine because JavaScript engines hoist the function declarations to the top of the scope. That means this code is treated as if the declaration came before the invocation. For function expressions, you must define the function before it is used, otherwise it causes an error. Example: In this case, doSomething() is undefined at the time of invocation and so causes a runtime error. Due to these different behaviors, it is common to have guidelines as to which style of function should be used. There is really no correct or incorrect choice here, it is just a preference.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"expression"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_FPN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>function-paren-newline</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>function-paren-newline</DisplayName>
        <Description>Many style guides require or disallow newlines inside of function parentheses.</Description>
        <HelpText>&lt;p&gt;Many style guides require or disallow newlines inside of function parentheses.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"multiline"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_IB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>id-blacklist</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>id-blacklist</DisplayName>
        <Description>Bad names can lead to hard-to-decipher code. Generic names, such as data, don’t infer much about the code and the values it receives. This rule allows you to configure a blacklist of bad identifier names, that you don’t want to see in your code.</Description>
        <HelpText>&lt;p&gt;Bad names can lead to hard-to-decipher code. Generic names, such as data, don’t infer much about the code and the values it receives. This rule allows you to configure a blacklist of bad identifier names, that you don’t want to see in your code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"data"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_IL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>id-length</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>id-length</DisplayName>
        <Description> Very short identifier names like e, x, _t or very long ones like hashGeneratorResultOutputContainerObject usually make the code harder to read and potentially less maintainable. To prevent this, one may enforce a minimum and/or maximum identifier length. (usually min 2-chars)</Description>
        <HelpText>&lt;p&gt;Very short identifier names like e, x, _t or very long ones like hashGeneratorResultOutputContainerObject usually make the code harder to read and potentially less maintainable. To prevent this, one may enforce a minimum and/or maximum identifier length. (usually min 2-chars)&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "min": 2,
                "properties": "always"
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_IM">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>id-match</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>id-match</DisplayName>
        <Description> Naming things consistently in a project is an often underestimated aspect of code creation. When done right, it can save your team hours of unnecessary head scratching and misdirections. This rule allows you to precisely define and enforce the variables and function names on your team should use. No more limiting yourself to camelCase, snake_case, PascalCase or oHungarianNotation. Id-match has all your needs covered!</Description>
        <HelpText>&lt;p&gt;Naming things consistently in a project is an often underestimated aspect of code creation. When done right, it can save your team hours of unnecessary head scratching and misdirections. This rule allows you to precisely define and enforce the variables and function names on your team should use. No more limiting yourself to camelCase, snake_case, PascalCase or oHungarianNotation. Id-match has all your needs covered!&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"^[a-z]+([A-Z][a-z]+)*$"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_IAL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>implicit-arrow-linebreak</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>implicit-arrow-linebreak</DisplayName>
        <Description>An arrow function body can contain an implicit return as an expression instead of a block body. It can be useful to enforce a consistent location for the implicitly returned expression.</Description>
        <HelpText>&lt;p&gt;An arrow function body can contain an implicit return as an expression instead of a block body. It can be useful to enforce a consistent location for the implicitly returned expression.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"beside"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_I">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>indent</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>indent</DisplayName>
        <Description>There are several common guidelines which require specific indentation of nested blocks and statements.</Description>
        <HelpText>&lt;p&gt;There are several common guidelines which require specific indentation of nested blocks and statements.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">2</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_JQ">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>jsx-quotes</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>jsx-quotes</DisplayName>
        <Description> JSX attribute values can contain string literals, which are delimited with single or double quotes. Unlike string literals in JavaScript, string literals within JSX attributes can’t contain escaped quotes. If you want to have e.g. a double quote within a JSX attribute value, you have to use single quotes as string delimiter.</Description>
        <HelpText>&lt;p&gt;JSX attribute values can contain string literals, which are delimited with single or double quotes. Unlike string literals in JavaScript, string literals within JSX attributes can’t contain escaped quotes. If you want to have e.g. a double quote within a JSX attribute value, you have to use single quotes as string delimiter.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "preferDouble" editable = "true">"prefer-double"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_KS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>key-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>key-spacing</DisplayName>
        <Description> This rule enforces spacing around the colon in object literal properties. It can verify each property individually, or it can ensure vertical alignment of groups of properties in an object literal.</Description>
        <HelpText>&lt;p&gt;This rule enforces spacing around the colon in object literal properties. It can verify each property individually, or it can ensure vertical alignment of groups of properties in an object literal.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "beforeColon": false,
                "afterColon": true,
                "mode": "strict"
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_KWS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>keyword-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>keyword-spacing</DisplayName>
        <Description> Keywords are syntax elements of JavaScript, such as function and if. These identifiers have special meaning to the language and so often appear in a different color in code editors. As an important part of the language, style guides often refer to the spacing that should be used around keywords. For example, you might have a style guide that says keywords should be always surrounded by spaces.</Description>
        <HelpText>&lt;p&gt;Keywords are syntax elements of JavaScript, such as function and if. These identifiers have special meaning to the language and so often appear in a different color in code editors. As an important part of the language, style guides often refer to the spacing that should be used around keywords. For example, you might have a style guide that says keywords should be always surrounded by spaces. &lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "before": true,
            "after": true,
            "overrides":{}
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_LCP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>line-comment-position</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>line-comment-position</DisplayName>
        <Description> Line comments can be positioned above or beside code. This rule helps teams maintain a consistent style.</Description>
        <HelpText>&lt;p&gt;Line comments can be positioned above or beside code. This rule helps teams maintain a consistent style.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        { "position": "above" }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_LS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>linebreak-style</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>linebreak-style</DisplayName>
        <Description> When developing with a lot of people all having different editors, VCS applications and operating systems it may occur that different line endings are written by either of the mentioned (might especially happen when using the windows and mac versions of SourceTree together). The linebreaks (new lines) used in windows operating system are usually carriage returns (CR) followed by a line feed (LF) making it a carriage return line feed (CRLF) whereas Linux and Unix use a simple line feed (LF). The corresponding control sequences are &quot;\n&quot; (for LF) and &quot;\r\n&quot; for (CRLF). Many versioning systems (like git and subversion) can automatically ensure the correct ending. However to cover all contingencies you can activate this rule.</Description>
        <HelpText>&lt;p&gt;When developing with a lot of people all having different editors, VCS applications and operating systems it may occur that different line endings are written by either of the mentioned (might especially happen when using the windows and mac versions of SourceTree together). The linebreaks (new lines) used in windows operating system are usually carriage returns (CR) followed by a line feed (LF) making it a carriage return line feed (CRLF) whereas Linux and Unix use a simple line feed (LF). The corresponding control sequences are “” (for LF) and “” for (CRLF). Many versioning systems (like git and subversion) can automatically ensure the correct ending. However to cover all contingencies you can activate this rule.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"unix"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_LAC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>lines-around-comment</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>lines-around-comment</DisplayName>
        <Description> Many style guides require empty lines before or after comments. The primary goal of these rules is to make the comments easier to read and improve readability of the code.</Description>
        <HelpText>&lt;p&gt;Many style guides require empty lines before or after comments. The primary goal of these rules is to make the comments easier to read and improve readability of the code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "beforeBlockComment": true
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_LBCM">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>lines-between-class-members</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>lines-between-class-members</DisplayName>
        <Description>This rule improves readability by enforcing lines between class members. It will not check empty lines before the first member and after the last member, since that is already taken care of by padded-blocks.</Description>
        <HelpText>&lt;p&gt;This rule improves readability by enforcing lines between class members. It will not check empty lines before the first member and after the last member, since that is already taken care of by padded-blocks.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MD">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-depth</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-depth</DisplayName>
        <Description>Many developers consider code difficult to read if blocks are nested beyond a certain depth.</Description>
        <HelpText>&lt;p&gt;Many developers consider code difficult to read if blocks are nested beyond a certain depth.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 4 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_ML">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-len</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-len</DisplayName>
        <Description> Very long lines of code in any language can be difficult to read. In order to aid in readability and maintainability many coders have developed a convention to limit lines of code to X number of characters (traditionally 80 characters).</Description>
        <HelpText>&lt;p&gt;Very long lines of code in any language can be difficult to read. In order to aid in readability and maintainability many coders have developed a convention to limit lines of code to X number of characters (traditionally 80 characters).&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "code": 80,
                "tabWidth": 4,
                "comments": 65,
                "ignoreComments": true,
                "ignoreTrailingComments": true,
                "ignoreUrls": true,
                "ignoreStrings": true,
                "ignoreTemplateLiterals": true,
                "ignoreRegExpLiterals": true
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MLINES">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-lines</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-lines</DisplayName>
        <Description>Some people consider large files a code smell. Large files tend to do a lot of things and can make it hard following what’s going. While there is not an objective maximum number of lines considered acceptable in a file, most people would agree it should not be in the thousands. Recommendations usually range from 100 to 500 lines.</Description>
        <HelpText>&lt;p&gt;Some people consider large files a code smell. Large files tend to do a lot of things and can make it hard following what’s going. While there is not an objective maximum number of lines considered acceptable in a file, most people would agree it should not be in the thousands. Recommendations usually range from 100 to 500 lines.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "max": 300,
                "skipBlankLines": true,
                "skipComments": true
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MNC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-nested-callbacks</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-nested-callbacks</DisplayName>
        <Description> Many JavaScript libraries use the callback pattern to manage asynchronous operations. A program of any complexity will most likely need to manage several asynchronous operations at various levels of concurrency. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested.</Description>
        <HelpText>&lt;p&gt;Many JavaScript libraries use the callback pattern to manage asynchronous operations. A program of any complexity will most likely need to manage several asynchronous operations at various levels of concurrency. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 10 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-params</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-params</DisplayName>
        <Description> Functions that take numerous parameters can be difficult to read and write because it requires the memorization of what each parameter is, its type, and the order they should appear in. As a result, many coders adhere to a convention that caps the number of parameters a function can take.</Description>
        <HelpText>&lt;p&gt;Functions that take numerous parameters can be difficult to read and write because it requires the memorization of what each parameter is, its type, and the order they should appear in. As a result, many coders adhere to a convention that caps the number of parameters a function can take.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 3 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-statements</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-statements</DisplayName>
        <Description> The max-statements rule allows you to specify the maximum number of statements allowed in a function.</Description>
        <HelpText>&lt;p&gt;The max-statements rule allows you to specify the maximum number of statements allowed in a function.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 10 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MSPL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>max-statements-per-line</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>max-statements-per-line</DisplayName>
        <Description> A line of code containing too many statements can be difficult to read. Code is generally read from the top down, especially when scanning, so limiting the number of statements allowed on a single line can be very beneficial for readability and maintainability.</Description>
        <HelpText>&lt;p&gt;A line of code containing too many statements can be difficult to read. Code is generally read from the top down, especially when scanning, so limiting the number of statements allowed on a single line can be very beneficial for readability and maintainability.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 1 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MCS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>multiline-comment-style</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>multiline-comment-style</DisplayName>
        <Description>Many style guides require a particular style for comments that span multiple lines. For example, some style guides prefer the use of a single block comment for multiline comments, whereas other style guides prefer consecutive line comments.</Description>
        <HelpText>&lt;p&gt;Many style guides require a particular style for comments that span multiple lines. For example, some style guides prefer the use of a single block comment for multiline comments, whereas other style guides prefer consecutive line comments.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"starred-block"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_MT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>multiline-ternary</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>multiline-ternary</DisplayName>
        <Description>JavaScript allows operands of ternary expressions to be separated by newlines, which can improve the readability of your program.</Description>
        <HelpText>&lt;p&gt;JavaScript allows operands of ternary expressions to be separated by newlines, which can improve the readability of your program.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCAP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>new-cap</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>new-cap</DisplayName>
        <Description> The new operator in JavaScript creates a new instance of a particular type of object. That type of object is represented by a constructor function. Since constructor functions are just regular functions, the only defining characteristic is that new is being used as part of the call. Native JavaScript functions begin with an uppercase letter to distinguish those functions that are to be used as constructors from functions that are not. Many style guides recommend following this pattern to more easily determine which functions are to be used as constructors.</Description>
        <HelpText>&lt;p&gt;The new operator in JavaScript creates a new instance of a particular type of object. That type of object is represented by a constructor function. Since constructor functions are just regular functions, the only defining characteristic is that new is being used as part of the call. Native JavaScript functions begin with an uppercase letter to distinguish those functions that are to be used as constructors from functions that are not. Many style guides recommend following this pattern to more easily determine which functions are to be used as constructors.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "newIsCap": true,
                "capIsNew": true,
                "properties": true
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>new-parens</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>new-parens</DisplayName>
        <Description> JavaScript allows the omission of parentheses when invoking a function via the new keyword and the constructor has no arguments. However, some coders believe that omitting the parentheses is inconsistent with the rest of the language and thus makes code less clear.</Description>
        <HelpText>&lt;p&gt;JavaScript allows the omission of parentheses when invoking a function via the new keyword and the constructor has no arguments. However, some coders believe that omitting the parentheses is inconsistent with the rest of the language and thus makes code less clear.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPCC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>newline-per-chained-call</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>newline-per-chained-call</DisplayName>
        <Description>Chained method calls on a single line without line breaks are harder to read, so some developers place a newline character after each method call in the chain to make it more readable and easy to maintain.</Description>
        <HelpText>&lt;p&gt;Chained method calls on a single line without line breaks are harder to read, so some developers place a newline character after each method call in the chain to make it more readable and easy to maintain.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "ignoreChainWithDepth": 2 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NAC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-array-constructor</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-array-constructor</DisplayName>
        <Description> Use of the Array constructor to construct a new array is generally discouraged in favour of array literal notation because of the single-argument pitfall and because the Array global may be redefined. The exception is when the Array constructor is used to intentionally create sparse arrays of a specified size by giving the constructor a single numeric argument.</Description>
        <HelpText>&lt;p&gt;Use of the Array constructor to construct a new array is generally discouraged in favour of array literal notation because of the single-argument pitfall and because the Array global may be redefined. The exception is when the Array constructor is used to intentionally create sparse arrays of a specified size by giving the constructor a single numeric argument.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-bitwise</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-bitwise</DisplayName>
        <Description> The use of bitwise operators in JavaScript is very rare and often &amp; or | is simply a mistyped &amp;&amp; or ||, which will lead to unexpected behavior.</Description>
        <HelpText>&lt;p&gt;The use of bitwise operators in JavaScript is very rare and often &amp;amp; or | is simply a mistyped &amp;amp;&amp;amp; or ||, which will lead to unexpected behavior.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
            "allow": ["~"],
            "int32Hint": true
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NCO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-continue</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-continue</DisplayName>
        <Description> The continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration. When used incorrectly it makes code less testable, less readable and less maintainable. Structured control flow statements such as if should be used instead.</Description>
        <HelpText>&lt;p&gt;The continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration. When used incorrectly it makes code less testable, less readable and less maintainable. Structured control flow statements such as if should be used instead.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NICO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-inline-comments</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-inline-comments</DisplayName>
        <Description> Some style guides disallow a comments on the same line as code. If there are comments immediately following code, it can make it harder to read the code. On the other hand, it is sometimes faster and more obvious to put comments immediately following code.</Description>
        <HelpText>&lt;p&gt;Some style guides disallow a comments on the same line as code. If there are comments immediately following code, it can make it harder to read the code. On the other hand, it is sometimes faster and more obvious to put comments immediately following code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NLI">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-lonely-if</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-lonely-if</DisplayName>
        <Description> If an if statement is the only statement in the else block of a parent if statement, it is often clearer to combine the two to using else if form. should be rewritten as</Description>
        <HelpText>&lt;p&gt;If an if statement is the only statement in the else block of a parent if statement, it is often clearer to combine the two to using else if form. should be rewritten as&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-mixed-operators</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-mixed-operators</DisplayName>
        <Description>Enclosing complex expressions by parentheses clarifies the developer’s intention, which makes the code more readable. This rule warns when different operators are used consecutively without parentheses in an expression.</Description>
        <HelpText>&lt;p&gt;Enclosing complex expressions by parentheses clarifies the developer’s intention, which makes the code more readable. This rule warns when different operators are used consecutively without parentheses in an expression.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "groups": [
                ["+", "-", "*", "/", "%", "**"],
                ["&amp;", "|", "^", "~", "&lt;&lt;", "&gt;&gt;", "&gt;&gt;&gt;"],
                ["==", "!=", "===", "!==", "&gt;", "&gt;=", "&lt;", "&lt;="],
                ["&amp;&amp;", "||"],
                ["in", "instanceof"]
            ],
            "allowSamePrecedence": true
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMSAT">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-mixed-spaces-and-tabs</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-mixed-spaces-and-tabs</DisplayName>
        <Description> Most code conventions require either tabs or spaces be used for indentation. As such, it&apos;s usually an error if a single line of code is indented with both tabs and spaces.</Description>
        <HelpText>&lt;p&gt;Most code conventions require either tabs or spaces be used for indentation. As such, it’s usually an error if a single line of code is indented with both tabs and spaces.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true"></Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-multi-assign</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-multi-assign</DisplayName>
        <Description>Chaining the assignment of variables can lead to unexpected results and be difficult to read.</Description>
        <HelpText>&lt;p&gt;Chaining the assignment of variables can lead to unexpected results and be difficult to read.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NMEL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-multiple-empty-lines</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-multiple-empty-lines</DisplayName>
        <Description> Some developers prefer to have multiple blank lines removed, while others feel that it helps improve readability. Whitespace is useful for separating logical sections of code, but excess whitespace takes up more of the screen.</Description>
        <HelpText>&lt;p&gt;Some developers prefer to have multiple blank lines removed, while others feel that it helps improve readability. Whitespace is useful for separating logical sections of code, but excess whitespace takes up more of the screen.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "max": 1 }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NNC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-negated-condition</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-negated-condition</DisplayName>
        <Description>Negated conditions are more difficult to understand. Code can be made more readable by inverting the condition instead.</Description>
        <HelpText>&lt;p&gt;Negated conditions are more difficult to understand. Code can be made more readable by inverting the condition instead.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NNT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-nested-ternary</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-nested-ternary</DisplayName>
        <Description> Nesting ternary expressions makes code unclear. The no-nested-ternary rule disallows the use of nested ternary expressions.</Description>
        <HelpText>&lt;p&gt;Nesting ternary expressions makes code unclear. The no-nested-ternary rule disallows the use of nested ternary expressions.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NNO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-new-object</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-new-object</DisplayName>
        <Description> The Object constructor is used to create new generic objects in JavaScript, such as: However, this is no different from using the more concise object literal syntax: For this reason, many prefer to always use the object literal syntax and never use the Object constructor. While there are no performance differences between the two approaches, the byte savings and conciseness of the object literal form is what has made it the de facto way of creating new objects.</Description>
        <HelpText>&lt;p&gt;The Object constructor is used to create new generic objects in JavaScript, such as: However, this is no different from using the more concise object literal syntax: For this reason, many prefer to always use the object literal syntax and never use the Object constructor. While there are no performance differences between the two approaches, the byte savings and conciseness of the object literal form is what has made it the de facto way of creating new objects.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NPL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-plusplus</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-plusplus</DisplayName>
        <Description>Because the unary ++ and -- operators are subject to automatic semicolon insertion, differences in whitespace can change semantics of source code.</Description>
        <HelpText>&lt;p&gt;Because the unary ++ and -- operators are subject to automatic semicolon insertion, differences in whitespace can change semantics of source code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "allowForLoopAfterthoughts": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRSY">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-restricted-syntax</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-restricted-syntax</DisplayName>
        <Description> JavaScript has a lot of language features, and not everyone likes every features. As a result, some projects choose to disallow the use of certain language features altogether. For instance, you might decide to disallow the use of try-catch or class. Rather than creating separate rules for every language feature you want to turn off, this rule allows you to configure the syntax elements you want to restrict use of. These elements are represented by their ESTree node types. For example, a function declaration is represented by FunctionDeclaration and the with statement is represented by WithStatement. You may find the full list of AST node names you can use on GitHub and use the online parser to see what type of nodes your code consists of.</Description>
        <HelpText>&lt;p&gt;JavaScript has a lot of language features, and not everyone likes every features. As a result, some projects choose to disallow the use of certain language features altogether. For instance, you might decide to disallow the use of try-catch or class. Rather than creating separate rules for every language feature you want to turn off, this rule allows you to configure the syntax elements you want to restrict use of. These elements are represented by their ESTree node types. For example, a function declaration is represented by FunctionDeclaration and the with statement is represented by WithStatement. You may find the full list of AST node names you can use on GitHub and use the online parser to see what type of nodes your code consists of.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true"></Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NRSY">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-tabs</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-tabs</DisplayName>
        <Description>Some style guides don’t allow the use of tab characters at all, including within comments.</Description>
        <HelpText>&lt;p&gt;Some style guides don’t allow the use of tab characters at all, including within comments.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true"></Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-ternary</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-ternary</DisplayName>
        <Description> The ternary operator is used to conditionally assign a value to a variable. Some believe that the use of ternary operators leads to unclear code.</Description>
        <HelpText>&lt;p&gt;The ternary operator is used to conditionally assign a value to a variable. Some believe that the use of ternary operators leads to unclear code.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NTS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-trailing-spaces</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-trailing-spaces</DisplayName>
        <Description> Sometimes in the course of editing files, you can end up with extra whitespace at the end of lines. These whitespace differences can be picked up by source control systems and flagged as diffs, causing frustration for developers. While this extra whitespace causes no functional issues, many code conventions require that trailing spaces be removed before checkin. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;Sometimes in the course of editing files, you can end up with extra whitespace at the end of lines. These whitespace differences can be picked up by source control systems and flagged as diffs, causing frustration for developers. While this extra whitespace causes no functional issues, many code conventions require that trailing spaces be removed before checkin. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "skipBlankLines": false,
            "ignoreComments": false
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUD">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-underscore-dangle</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-underscore-dangle</DisplayName>
        <Description> As far as naming conventions for identifiers go, dangling underscores may be the most polarizing in JavaScript. Dangling underscores are underscores at either the beginning or end of an identifier, such as: There is actually a long history of using dangling underscores to indicate &quot;private&quot; members of objects in JavaScript (though JavaScript doesn&apos;t have truly private members, this convention served as a warning). This began with SpiderMonkey adding nonstandard methods such as __defineGetter__(). The intent with the underscores was to make it obvious that this method was special in some way. Since that time, using a single underscore prefix has become popular as a way to indicate &quot;private&quot; members of objects. Whether or not you choose to allow dangling underscores in identifiers is purely a convention and has no effect on performance, readability, or complexity. It&apos;s purely a preference.</Description>
        <HelpText>&lt;p&gt;As far as naming conventions for identifiers go, dangling underscores may be the most polarizing in JavaScript. Dangling underscores are underscores at either the beginning or end of an identifier, such as: There is actually a long history of using dangling underscores to indicate “private” members of objects in JavaScript (though JavaScript doesn’t have truly private members, this convention served as a warning). This began with SpiderMonkey adding nonstandard methods such as &lt;strong&gt;defineGetter&lt;/strong&gt;(). The intent with the underscores was to make it obvious that this method was special in some way. Since that time, using a single underscore prefix has become popular as a way to indicate “private” members of objects. Whether or not you choose to allow dangling underscores in identifiers is purely a convention and has no effect on performance, readability, or complexity. It’s purely a preference.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "allow": [] }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NUT">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-unneeded-ternary</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-unneeded-ternary</DisplayName>
        <Description> It&apos;s a common mistake in JavaScript to use a conditional expression to select between two Boolean values instead of using ! to convert the test to a Boolean. Here are some examples: This rule disallows the use of &apos;Boolean&apos; literals inside conditional expressions. Another common mistake is using a single variable as both the conditional test and the consequent. In such cases, the logical OR can be used to provide the same functionality. Here is an example: This rule disallows the conditional expression as a default assignment pattern when the defaultAssignment option is set to false.</Description>
        <HelpText>&lt;p&gt;It’s a common mistake in JavaScript to use a conditional expression to select between two Boolean values instead of using ! to convert the test to a Boolean. Here are some examples: This rule disallows the use of ‘Boolean’ literals inside conditional expressions. Another common mistake is using a single variable as both the conditional test and the consequent. In such cases, the logical OR can be used to provide the same functionality. Here is an example: This rule disallows the conditional expression as a default assignment pattern when the defaultAssignment option is set to false.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "defaultAssignment": true
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NWBP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>no-whitespace-before-property</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-whitespace-before-property</DisplayName>
        <Description>JavaScript allows whitespace between objects and their properties. However, inconsistent spacing can make code harder to read and can lead to errors.</Description>
        <HelpText>&lt;p&gt;JavaScript allows whitespace between objects and their properties. However, inconsistent spacing can make code harder to read and can lead to errors.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_NSBP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>nonblock-statement-body-position</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>nonblock-statement-body-position</DisplayName>
        <Description>When writing if, else, while, do-while, and for statements, the body can be a single statement instead of a block. It can be useful to enforce a consistent location for these single statements.</Description>
        <HelpText>&lt;p&gt;When writing if, else, while, do-while, and for statements, the body can be a single statement instead of a block. It can be useful to enforce a consistent location for these single statements.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"beside"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OCN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>object-curly-newline</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>object-curly-newline</DisplayName>
        <Description>A number of style guides require or disallow line breaks inside of object braces and other tokens.</Description>
        <HelpText>&lt;p&gt;A number of style guides require or disallow line breaks inside of object braces and other tokens.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">{ "multiline": true }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OCS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>object-curly-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>object-curly-spacing</DisplayName>
        <Description> While formatting preferences are very personal, a number of style guides require or disallow spaces between curly braces.</Description>
        <HelpText>&lt;p&gt;While formatting preferences are very personal, a number of style guides require or disallow spaces between curly braces.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"never"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OPN">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>object-curly-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>object-curly-spacing</DisplayName>
        <Description> This rule permits you to restrict the locations of property specifications in object literals. You may prohibit any part of any property specification from appearing on the same line as any part of any other property specification. You may make this prohibition absolute, or, by invoking an object option, you may allow an exception, permitting an object literal to have all parts of all of its property specifications on a single line.</Description>
        <HelpText>&lt;p&gt;This rule permits you to restrict the locations of property specifications in object literals. You may prohibit any part of any property specification from appearing on the same line as any part of any other property specification. You may make this prohibition absolute, or, by invoking an object option, you may allow an exception, permitting an object literal to have all parts of all of its property specifications on a single line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OV">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>one-var</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>one-var</DisplayName>
        <Description> Variables can be declared at any point in JavaScript code using var, let, or const. There are many styles and preferences related to the declaration of variables, and one of those is deciding on how many variable declarations should be allowed in a single function. There are two schools of thought in this regard: For instance: The single-declaration school of thought is based in pre-ECMAScript 6 behaviors, where there was no such thing as block scope, only function scope. Since all var statements are hoisted to the top of the function anyway, some believe that declaring all variables in a single declaration at the top of the function removes confusion around scoping rules.</Description>
        <HelpText>&lt;p&gt;Variables can be declared at any point in JavaScript code using var, let, or const. There are many styles and preferences related to the declaration of variables, and one of those is deciding on how many variable declarations should be allowed in a single function. There are two schools of thought in this regard: For instance: The single-declaration school of thought is based in pre-ECMAScript 6 behaviors, where there was no such thing as block scope, only function scope. Since all var statements are hoisted to the top of the function anyway, some believe that declaring all variables in a single declaration at the top of the function removes confusion around scoping rules.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OVPL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>one-var-declaration-per-line</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>one-var-declaration-per-lines</DisplayName>
        <Description>Some developers declare multiple var statements on the same line, others prefer to declare one var per line. Keeping to one of these styles across a project’s codebase can help with maintaining code consistency.</Description>
        <HelpText>&lt;p&gt;Some developers declare multiple var statements on the same line, others prefer to declare one var per line. Keeping to one of these styles across a project’s codebase can help with maintaining code consistency.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"initializations"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OA">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>operator-assignment</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>operator-assignment</DisplayName>
        <Description> JavaScript provides shorthand operators that combine variable assignment and some simple mathematical operations. For example, x = x + 4 can be shortened to x += 4. The supported shorthand forms are as follows:</Description>
        <HelpText>&lt;p&gt;JavaScript provides shorthand operators that combine variable assignment and some simple mathematical operations. For example, x = x + 4 can be shortened to x += 4. The supported shorthand forms are as follows:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_OL">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>operator-linebreak</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>operator-linebreak</DisplayName>
        <Description> When a statement is too long to fit on a single line, line breaks are generally inserted next to the operators separating expressions. The first style coming to mind would be to place the operator at the end of the line, following the english punctuation rules. Some developers find that placing operators at the beginning of the line makes the code more readable.</Description>
        <HelpText>&lt;p&gt;When a statement is too long to fit on a single line, line breaks are generally inserted next to the operators separating expressions. The first style coming to mind would be to place the operator at the end of the line, following the english punctuation rules. Some developers find that placing operators at the beginning of the line makes the code more readable.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true"></Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_PB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>padded-blocks</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>padded-blocks</DisplayName>
        <Description> Some style guides require block statements to start and end with blank lines. The goal is to improve readability by visually separating the block content and the surrounding code. Since it&apos;s good to have a consistent code style, you should either always write padded blocks or never do it.</Description>
        <HelpText>&lt;p&gt;Some style guides require block statements to start and end with blank lines. The goal is to improve readability by visually separating the block content and the surrounding code. Since it’s good to have a consistent code style, you should either always write padded blocks or never do it.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_PLBS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>padding-line-between-statements</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>padding-line-between-statements</DisplayName>
        <Description>This rule requires or disallows blank lines between the given 2 kinds of statements. Properly blank lines help developers to understand the code. For example, the following configuration requires a blank line between a variable declaration and a return statement.</Description>
        <HelpText>&lt;p&gt;This rule requires or disallows blank lines between the given 2 kinds of statements. Properly blank lines help developers to understand the code. For example, the following configuration requires a blank line between a variable declaration and a return statement.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_QP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>quote-props</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>quote-props</DisplayName>
        <Description> Object literal property names can be defined in two ways: using literals or using strings. For example, these two objects are equivalent: In many cases, it doesn&apos;t matter if you choose to use an identifier instead of a string or vice-versa. Even so, you might decide to enforce a consistent style in your code. There are, however, some occasions when you must use quotes: Another example where quotes do matter is when using numeric literals as property keys: This may look alright at first sight, but this code in fact throws a syntax error in ECMAScript 5 strict mode. This happens because 1e2 and 100 are coerced into strings before getting used as the property name. Both String(1e2) and String(100) happen to be equal to &quot;100&quot;, which causes the &quot;Duplicate data property in object literal not allowed in strict mode&quot; error. Issues like that can be tricky to debug, so some prefer to require quotes around all property names.</Description>
        <HelpText>&lt;p&gt;Object literal property names can be defined in two ways: using literals or using strings. For example, these two objects are equivalent: In many cases, it doesn’t matter if you choose to use an identifier instead of a string or vice-versa. Even so, you might decide to enforce a consistent style in your code. There are, however, some occasions when you must use quotes: Another example where quotes do matter is when using numeric literals as property keys: This may look alright at first sight, but this code in fact throws a syntax error in ECMAScript 5 strict mode. This happens because 1e2 and 100 are coerced into strings before getting used as the property name. Both String(1e2) and String(100) happen to be equal to “100”, which causes the “Duplicate data property in object literal not allowed in strict mode” error. Issues like that can be tricky to debug, so some prefer to require quotes around all property names.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_Q">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>quotes</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>quotes</DisplayName>
        <Description> JavaScript allows you to define strings in one of three ways: double quotes, single quotes, and backticks (as of ECMAScript 6). For example: Each of these lines creates a string and, in some cases, can be used interchangeably. The choice of how to define strings in a codebase is a stylistic one outside of template literals (which allow embedded of expressions to be interpreted). Many codebases require strings to be defined in a consistent manner.</Description>
        <HelpText>&lt;p&gt;JavaScript allows you to define strings in one of three ways: double quotes, single quotes, and backticks (as of ECMAScript 6). For example: Each of these lines creates a string and, in some cases, can be used interchangeably. The choice of how to define strings in a codebase is a stylistic one outside of template literals (which allow embedded of expressions to be interpreted). Many codebases require strings to be defined in a consistent manner.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"double"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_RJ">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>require-jsdoc</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>require-jsdoc</DisplayName>
        <Description> JSDoc is a JavaScript API documentation generator. It uses specially-formatted comments inside of code to generate API documentation automatically. For example, this is what a JSDoc comment looks like for a function: Some style guides require JSDoc comments for all functions as a way of explaining function behavior.</Description>
        <HelpText>&lt;p&gt;JSDoc is a JavaScript API documentation generator. It uses specially-formatted comments inside of code to generate API documentation automatically. For example, this is what a JSDoc comment looks like for a function: Some style guides require JSDoc comments for all functions as a way of explaining function behavior.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "require": {
                "FunctionDeclaration": true,
                "MethodDefinition": false,
                "ClassDeclaration": false,
                "ArrowFunctionExpression": false,
                "FunctionExpression": false
            }
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>semi</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>semi</DisplayName>
        <Description> JavaScript is unique amongst the C-like languages in that it doesn&apos;t require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as automatic semicolon insertion (ASI) and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid: On the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement. In the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn&apos;t exist and always include semicolons manually. The rationale is that it&apos;s easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error. However, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code: This may look like a return statement that returns an object literal, however, the JavaScript engine will interpret this code as: Effectively, a semicolon is inserted after the return statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the no-unreachable rule will protect your code from such cases. On the other side of the argument are those who says that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don&apos;t use semicolons. For example, consider this code: In this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it&apos;s a function). The no-unexpected-multiline rule can protect your code from such cases. Although ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a \n character always ends a statement (just like a semicolon) unless one of the following is true:</Description>
        <HelpText>&lt;p&gt;JavaScript is unique amongst the C-like languages in that it doesn’t require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as automatic semicolon insertion (ASI) and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid: On the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement. In the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn’t exist and always include semicolons manually. The rationale is that it’s easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error. However, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code: This may look like a return statement that returns an object literal, however, the JavaScript engine will interpret this code as: Effectively, a semicolon is inserted after the return statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the no-unreachable rule will protect your code from such cases. On the other side of the argument are those who says that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don’t use semicolons. For example, consider this code: In this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it’s a function). The no-unexpected-multiline rule can protect your code from such cases. Although ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a character always ends a statement (just like a semicolon) unless one of the following is true:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>semi-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>semi-spacing</DisplayName>
        <Description> JavaScript allows you to place unnecessary spaces before or after a semicolon. Disallowing or enforcing space around a semicolon can improve the readability of your program.</Description>
        <HelpText>&lt;p&gt;JavaScript allows you to place unnecessary spaces before or after a semicolon. Disallowing or enforcing space around a semicolon can improve the readability of your program.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "before": false,
                "after": true
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SSTYLE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>semi-style</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>semi-style</DisplayName>
        <Description>Generally, semicolons are at the end of lines. However, in semicolon-less style, semicolons are at the beginning of lines. This rule enforces that semicolons are at the configured location.</Description>
        <HelpText>&lt;p&gt;Generally, semicolons are at the end of lines. However, in semicolon-less style, semicolons are at the beginning of lines. This rule enforces that semicolons are at the configured location.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"last"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SK">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>sort-keys</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>sort-keys</DisplayName>
        <Description>This rule checks all property definitions of object expressions and verifies that all variables are sorted alphabetically.</Description>
        <HelpText>&lt;p&gt;This rule checks all property definitions of object expressions and verifies that all variables are sorted alphabetically.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"asc"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SV">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>sort-vars</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>sort-vars</DisplayName>
        <Description> When declaring multiple variables within the same block, some developers prefer to sort variable names alphabetically to be able to find necessary variable easier at the later time. Others feel that it adds complexity and becomes burden to maintain.</Description>
        <HelpText>&lt;p&gt;When declaring multiple variables within the same block, some developers prefer to sort variable names alphabetically to be able to find necessary variable easier at the later time. Others feel that it adds complexity and becomes burden to maintain.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "ignoreCase": true
        }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SBB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>space-before-blocks</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>space-before-blocks</DisplayName>
        <Description> Consistency is an important part of any style guide. While it is a personal preference where to put the opening brace of blocks, it should be consistent across a whole project. Having an inconsistent style distracts the reader from seeing the important parts of the code. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;Consistency is an important part of any style guide. While it is a personal preference where to put the opening brace of blocks, it should be consistent across a whole project. Having an inconsistent style distracts the reader from seeing the important parts of the code. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SBFP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>space-before-function-paren</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>space-before-function-paren</DisplayName>
        <Description> When formatting a function, whitespace is allowed between the function name or function keyword and the opening paren. Named functions also require a space between the function keyword and the function name, but anonymous functions require no whitespace. For example: Style guides may require a space after the function keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;When formatting a function, whitespace is allowed between the function name or function keyword and the opening paren. Named functions also require a space between the function keyword and the function name, but anonymous functions require no whitespace. For example: Style guides may require a space after the function keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SIP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>space-in-parens</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>space-in-parens</DisplayName>
        <Description> Some style guides require or disallow spaces inside of parentheses:</Description>
        <HelpText>&lt;p&gt;Some style guides require or disallow spaces inside of parentheses:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"never"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SIO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>space-infix-ops</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>space-infix-ops</DisplayName>
        <Description> While formatting preferences are very personal, a number of style guides require spaces around operators, such as: The proponents of these extra spaces believe it make the code easier to read and can more easily highlight potential errors, such as: While this is valid JavaScript syntax, it is hard to determine what the author intended. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;While formatting preferences are very personal, a number of style guides require spaces around operators, such as: The proponents of these extra spaces believe it make the code easier to read and can more easily highlight potential errors, such as: While this is valid JavaScript syntax, it is hard to determine what the author intended. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
        {
            "int32Hint": false
        }</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SUO">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>space-unary-ops</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>space-unary-ops</DisplayName>
        <Description> Some styleguides require or disallow spaces before or after unary operators. This is mainly a stylistic issue, however, some JavaScript expressions can be written without spacing which makes it harder to read and maintain. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
        <HelpText>&lt;p&gt;Some styleguides require or disallow spaces before or after unary operators. This is mainly a stylistic issue, however, some JavaScript expressions can be written without spacing which makes it harder to read and maintain. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "words": true,
                "nonwords": false
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>spaced-comment</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>spaced-comment</DisplayName>
        <Description> Some style guides require or disallow a whitespace immediately after the initial // or /* of a comment. Whitespace after the // or /* makes it easier to read text in comments. On the other hand, commenting out code is easier without having to put a whitespace right after the // or /*.</Description>
        <HelpText>&lt;p&gt;Some style guides require or disallow a whitespace immediately after the initial // or /* of a comment. Whitespace after the // or /* makes it easier to read text in comments. On the other hand, commenting out code is easier without having to put a whitespace right after the // or /*.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">"always"</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_SCS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>switch-colon-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>switch-colon-spacing</DisplayName>
        <Description>Spacing around colons improves readability of case/default clauses.</Description>
        <HelpText>&lt;p&gt;Spacing around colons improves readability of case/default clauses.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            {
                "after": true,
                "before": false
            }
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_TTS">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>template-tag-spacing</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>template-tag-spacing</DisplayName>
        <Description>This rule aims to maintain consistency around the spacing between template tag functions and their template literals.</Description>
        <HelpText>&lt;p&gt;This rule aims to maintain consistency around the spacing between template tag functions and their template literals.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            "never"
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_UB">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>unicode-bom</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>unicode-bom</DisplayName>
        <Description>The Unicode Byte Order Mark (BOM) is used to specify whether code units are big endian or little endian. That is, whether the most significant or least significant bytes come first. UTF-8 does not require a BOM because byte ordering does not matter when characters are a single byte. Since UTF-8 is the dominant encoding of the web, we make "never" the default option.</Description>
        <HelpText>&lt;p&gt;The Unicode Byte Order Mark (BOM) is used to specify whether code units are big endian or little endian. That is, whether the most significant or least significant bytes come first. UTF-8 does not require a BOM because byte ordering does not matter when characters are a single byte. Since UTF-8 is the dominant encoding of the web, we make "never" the default option.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
        <Setting name = "__eslint_param__" editable = "true">
            "never"
        </Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "ESLINT_WR">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <OriginalId>wrap-regex</OriginalId>
      <GroupMember>Stylistic Issues</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>wrap-regex</DisplayName>
        <Description> When a regular expression is used in certain situations, it can end up looking like a division operator. For example:</Description>
        <HelpText>&lt;p&gt;When a regular expression is used in certain situations, it can end up looking like a division operator. For example:&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
<!-- ================================ -->
<!-- END OF Stylistic Issues category -->
<!-- ================================ -->



    <!-- ============================== -->
    <!-- ECMAScript6 START              -->
    <!-- ============================== -->
    <Metric id="ESLINT_ABST">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>arrow-body-style</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>arrow-body-style</DisplayName>
                <Description> Arrow functions can omit braces when there is a single statement in the body. This rule enforces the consistent use of braces in arrow functions. Additionally, this rule specifically warns against a possible developer error when the intention is to return an empty object literal but creates an empty block instead, returning undefined.</Description>
                <HelpText>&lt;p&gt;Arrow functions can omit braces when there is a single statement in the body. This rule enforces the consistent use of braces in arrow functions. Additionally, this rule specifically warns against a possible developer error when the intention is to return an empty object literal but creates an empty block instead, returning undefined.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">"as-needed"</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_APA">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>arrow-parens</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>arrow-parens</DisplayName>
                <Description> Arrow functions can omit parentheses when they have exactly one parameter. In all other cases the parameter(s) must be wrapped in parentheses. This rule enforces the consistent use of parentheses in arrow functions.</Description>
                <HelpText>&lt;p&gt;Arrow functions can omit parentheses when they have exactly one parameter. In all other cases the parameter(s) must be wrapped in parentheses. This rule enforces the consistent use of parentheses in arrow functions.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">"always"</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_AS">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>arrow-spacing</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>arrow-spacing</DisplayName>
                <Description> This rule normalize style of spacing before/after an arrow function's arrow(=&gt;). Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
                <HelpText>&lt;p&gt;This rule normalize style of spacing before/after an arrow function’s arrow(=&amp;gt;). Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"before": true, "after": true}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id = "ESLINT_CSU">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>constructor-super</OriginalId>
      <GroupMember>ECMAScript 6</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>constructor-super</DisplayName>
        <Description> Constructors of derived classes must call super(). Constructors of non derived classes must not call super(). If this is not observed, the javascript engine will raise a runtime error. This rule checks whether or not there is a valid super() call.</Description>
        <HelpText>&lt;p&gt;Constructors of derived classes must call super(). Constructors of non derived classes must not call super(). If this is not observed, the javascript engine will raise a runtime error. This rule checks whether or not there is a valid super() call.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
    <Metric id="ESLINT_GSS">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>generator-star-spacing</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>generator-star-spacing</DisplayName>
                <Description> Generators are a new type of function in ECMAScript 6 that can return multiple values over time. These special functions are indicated by placing an * after the function keyword. Here is an example of a generator function: This is also valid: This is valid as well: To keep a sense of consistency when using generators this rule enforces a single position for the *. Fixable: This rule is automatically fixable using the --fix flag on the command line.</Description>
                <HelpText>&lt;p&gt;Generators are a new type of function in ECMAScript 6 that can return multiple values over time. These special functions are indicated by placing an * after the function keyword. Here is an example of a generator function: This is also valid: This is valid as well: To keep a sense of consistency when using generators this rule enforces a single position for the *. Fixable: This rule is automatically fixable using the –fix flag on the command line.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"before": true, "after": false}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NCAR">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>no-confusing-arrow</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-confusing-arrow</DisplayName>
                <Description> Arrow functions (=&gt;) are similar in syntax to some comparison operators (&gt;, &lt;, &lt;=, and &gt;=). This rule warns against using the arrow function syntax in places where it could be confused with a comparison operator. Even if the arguments of the arrow function are wrapped with parens, this rule still warns about it unless allowParens is set to true.</Description>
                <HelpText>&lt;p&gt;Arrow functions (=&gt;) are similar in syntax to some comparison operators (&gt;, &lt;, &lt;=, and &gt;=). This rule warns against using the arrow function syntax in places where it could be confused with a comparison operator. Even if the arguments of the arrow function are wrapped with parens, this rule still warns about it unless allowParens is set to true.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"allowParens": false}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id = "ESLINT_NCAS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <OriginalId>no-class-assign</OriginalId>
      <GroupMember>ECMAScript 6</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>no-class-assign</DisplayName>
        <Description> ClassDeclaration creates a variable, and we can modify the variable. But the modification is a mistake in most cases.</Description>
        <HelpText>&lt;p&gt;ClassDeclaration creates a variable, and we can modify the variable. But the modification is a mistake in most cases.&lt;/p&gt;&#x0A;</HelpText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
    <Metric id="ESLINT_NCONS">
        <Configuration name="Default">
            <Enabled>true</Enabled>
            <Group>false</Group>
            <OriginalId>no-const-assign</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-const-assign</DisplayName>
                <Description> We cannot modify variables that are declared using const keyword. It will raise a runtime error. Under non ES2015 environment, it might be ignored merely.</Description>
                <HelpText>&lt;p&gt;We cannot modify variables that are declared using const keyword. It will raise a runtime error. Under non ES2015 environment, it might be ignored merely.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NDCM">
        <Configuration name="Default">
            <Enabled>true</Enabled>
            <Group>false</Group>
            <OriginalId>no-dupe-class-members</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-dupe-class-members</DisplayName>
                <Description> If there are declarations of the same name in class members, the last declaration overwrites other declarations silently. It can cause unexpected behaviors.</Description>
                <HelpText>&lt;p&gt;If there are declarations of the same name in class members, the last declaration overwrites other declarations silently. It can cause unexpected behaviors.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NDIM">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>no-duplicate-imports</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-duplicate-imports</DisplayName>
                <Description> Using a single import statement per module will make the code clearer because you can see everything being imported from that module on one line. In the following example the module import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.</Description>
                <HelpText>&lt;p&gt;Using a single import statement per module will make the code clearer because you can see everything being imported from that module on one line. In the following example the module import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"includeExports": false}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NNSY">
        <Configuration name="Default">
            <Enabled>true</Enabled>
            <Group>false</Group>
            <OriginalId>no-new-symbol</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-new-symbol</DisplayName>
                <Description> Using a single import statement per module will make the code clearer because you can see everything being imported from that module on one line. In the following example the module import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.</Description>
                <HelpText>&lt;p&gt;Using a single import statement per module will make the code clearer because you can see everything being imported from that module on one line. In the following example the module import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NRIM">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>no-restricted-imports</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-restricted-imports</DisplayName>
                <Description> Imports are an ES6/ES2015 standard for making the functionality of other modules available in your current module. In CommonJS this is implemented through the require() call which makes this ESLint rule roughly equivalent to its CommonJS counterpart no-restricted-modules.&lt;br /&gt;Why would you want to restrict imports?&lt;br /&gt;&lt;br /&gt;Some imports might not make sense in a particular environment. For example, Node.js’ fs module would not make sense in an environment that didn’t have a file system.&lt;br /&gt;Some modules provide similar or identical functionality, think lodash and underscore. Your project may have standardized on a module. You want to make sure that the other alternatives are not being used as this would unnecessarily bloat the project and provide a higher maintenance cost of two dependencies when one would suffice.</Description>
                <HelpText>&lt;p&gt;Imports are an ES6/ES2015 standard for making the functionality of other modules available in your current module. In CommonJS this is implemented through the require() call which makes this ESLint rule roughly equivalent to its CommonJS counterpart no-restricted-modules.&lt;br /&gt;Why would you want to restrict imports?&lt;br /&gt;&lt;br /&gt;Some imports might not make sense in a particular environment. For example, Node.js’ fs module would not make sense in an environment that didn’t have a file system.&lt;br /&gt;Some modules provide similar or identical functionality, think lodash and underscore. Your project may have standardized on a module. You want to make sure that the other alternatives are not being used as this would unnecessarily bloat the project and provide a higher maintenance cost of two dependencies when one would suffice.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"paths": ["exampleImport1", "exampleImport2"]}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NTBS">
        <Configuration name="Default">
            <Enabled>true</Enabled>
            <Group>false</Group>
            <OriginalId>no-this-before-super</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-this-before-super</DisplayName>
                <Description> In the constructor of derived classes, if this/super are used before super() calls, it raises a reference error. This rule checks this/super keywords in constructors, then reports those that are before super().</Description>
                <HelpText>&lt;p&gt;In the constructor of derived classes, if this/super are used before super() calls, it raises a reference error. This rule checks this/super keywords in constructors, then reports those that are before super().&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NUCK">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>no-useless-computed-key</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-useless-computed-key</DisplayName>
                <Description> The --fix option on the command line can automatically fix some of the problems reported by this rule.&lt;br /&gt;&lt;br /&gt;It’s unnecessary to use computed properties with literals such as:&lt;br /&gt;var foo = {["a"]: "b"};&lt;br /&gt;The code can be rewritten as:&lt;br /&gt;var foo = {"a": "b"};</Description>
                <HelpText>&lt;p&gt;The --fix option on the command line can automatically fix some of the problems reported by this rule.&lt;br /&gt;&lt;br /&gt;It’s unnecessary to use computed properties with literals such as:&lt;br /&gt;var foo = {["a"]: "b"};&lt;br /&gt;The code can be rewritten as:&lt;br /&gt;var foo = {"a": "b"};&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NUCO">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>no-useless-rename</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-useless-rename</DisplayName>
                <Description> ES2015 provides a default class constructor if one is not specified. As such, it is unnecessary to provide an empty constructor or one that simply delegates into its parent class.</Description>
                <HelpText>&lt;p&gt;ES2015 provides a default class constructor if one is not specified. As such, it is unnecessary to provide an empty constructor or one that simply delegates into its parent class&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{
			"ignoreDestructing": false,
			"ignoreImport": false,
			"ignoreExport": false
		}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_NVA">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>no-var</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>no-var</DisplayName>
                <Description> ECMAScript 6 allows programmers to create variables with block scope instead of function scope using the let and const keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes such as:</Description>
                <HelpText>&lt;p&gt;ECMAScript 6 allows programmers to create variables with block scope instead of function scope using the let and const keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes such as:&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_OS">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>object-shorthand</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>object-shorthand</DisplayName>
                <Description> EcmaScript 6 provides a concise form for defining object literal methods and properties. This syntax can make defining complex object literals much cleaner. Here are a few common examples using the ES5 syntax: Now here are ES6 equivalents:</Description>
                <HelpText>&lt;p&gt;EcmaScript 6 provides a concise form for defining object literal methods and properties. This syntax can make defining complex object literals much cleaner. Here are a few common examples using the ES5 syntax: Now here are ES6 equivalents:&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">"always"</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PAC">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-arrow-callback</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-arrow-callback</DisplayName>
                <Description> Arrow functions are suited to callbacks, because:</Description>
                <HelpText>&lt;p&gt;Arrow functions are suited to callbacks, because:&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"allowNamedFunction": false, "allowUnboundThis": true}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PC">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-const</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-const</DisplayName>
                <Description> If a variable is never modified, using the const declaration is better. const declaration tells readers, "this variable is never modified," reducing cognitive load and improving maintainability.</Description>
                <HelpText>&lt;p&gt;If a variable is never modified, using the const declaration is better. const declaration tells readers, “this variable is never modified,” reducing cognitive load and improving maintainability.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{
			"destructing": "any",
			"ignoreReadBeforeAssign": false
		}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PRED">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-destructing</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-destructing</DisplayName>
                <Description> With JavaScript ES6, a new syntax was added for creating variables from an array index or object property, called destructuring. This rule enforces usage of destructuring instead of accessing a property through a member expression.</Description>
                <HelpText>&lt;p&gt;With JavaScript ES6, a new syntax was added for creating variables from an array index or object property, called destructuring. This rule enforces usage of destructuring instead of accessing a property through a member expression.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">
			[{
				"array": true,
				"object": true
			}, {
				"enforceForRenamedProperties": false
			}]
	  </Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PNLI">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-numeric-literals</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-numeric-literals</DisplayName>
                <Description> The parseInt() and Number.parseInt() functions can be used to turn binary, octal, and hexadecimal strings into integers. As binary, octal, and hexadecimal literals are supported in ES6, this rule encourages use of those numeric literals instead of parseInt() or Number.parseInt()</Description>
                <HelpText>&lt;p&gt;The parseInt() and Number.parseInt() functions can be used to turn binary, octal, and hexadecimal strings into integers. As binary, octal, and hexadecimal literals are supported in ES6, this rule encourages use of those numeric literals instead of parseInt() or Number.parseInt()&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PRRP">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-rest-params</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-rest-params</DisplayName>
                <Description> There are rest parameters in ES2015. We can use that feature for variadic functions instead of the arguments variable. Arguments does not have methods of Array.prototype, so it’s a bit of an inconvenience.</Description>
                <HelpText>&lt;p&gt;There are rest parameters in ES2015. We can use that feature for variadic functions instead of the arguments variable. Arguments does not have methods of Array.prototype, so it’s a bit of an inconvenience.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PS">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-spread</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-spread</DisplayName>
                <Description> Before ES2015, one must use Function.prototype.apply() to call variadic functions. In ES2015, one can use the spread operator to call variadic functions.</Description>
                <HelpText>&lt;p&gt;Before ES2015, one must use Function.prototype.apply() to call variadic functions. In ES2015, one can use the spread operator to call variadic functions.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_PTEM">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>prefer-template</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>prefer-template</DisplayName>
                <Description> In ES2015 (ES6), we can use template literals instead of string concatenation.</Description>
                <HelpText>&lt;p&gt;In ES2015 (ES6), we can use template literals instead of string concatenation.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_RY">
        <Configuration name="Default">
            <Enabled>true</Enabled>
            <Group>false</Group>
            <OriginalId>require-yield</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>require-yield</DisplayName>
                <Description> This rule generates warnings for generator functions that do not have the yield keyword.</Description>
                <HelpText>&lt;p&gt;This rule generates warnings for generator functions that do not have the yield keyword.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_RSSP">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>rest-spread-spacing</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>rest-spread-spacing</DisplayName>
                <Description> ES2015 introduced the rest and spread operators, which expand an iterable structure into its individual parts. Some examples of their usage are as follows.</Description>
                <HelpText>&lt;p&gt;ES2015 introduced the rest and spread operators, which expand an iterable structure into its individual parts. Some examples of their usage are as follows.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">"never"</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_SIMP">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>sort-imports</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>sort-imports</DisplayName>
                <Description> The import statement is used to import members (functions, objects or primitives) that have been exported from an external module. Using a specific member syntax:</Description>
                <HelpText>&lt;p&gt;The import statement is used to import members (functions, objects or primitives) that have been exported from an external module. Using a specific member syntax:&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{
			"ignoreCase": false,
			"ignoreMemberSort": false,
			"memberSyntaxSortOrder": ["none", "all", "multiple", "single"]
		}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_SIMD">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>symbol-description</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>symbol-description</DisplayName>
                <Description> The Symbol function may have optional description. Using description promotes easier debugging: when a symbol is logged the description is used.</Description>
                <HelpText>&lt;p&gt;The Symbol function may have optional description. Using description promotes easier debugging: when a symbol is logged the description is used.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_TECS">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>template-curly-spacing</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>template-curly-spacing</DisplayName>
                <Description> We can embed expressions in template strings with using a pair of ${ and }. This rule can force usage of spacing within the curly brace pair according to style guides.</Description>
                <HelpText>&lt;p&gt;We can embed expressions in template strings with using a pair of ${ and }. This rule can force usage of spacing within the curly brace pair according to style guides.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">"never"</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
    <Metric id="ESLINT_YSSP">
        <Configuration name="Default">
            <Enabled>false</Enabled>
            <Group>false</Group>
            <OriginalId>yield-star-spacing</OriginalId>
            <GroupMember>ECMAScript 6</GroupMember>
            <Language lang="eng">
                <Warning>true</Warning>
                <DisplayName>yield-star-spacing</DisplayName>
                <Description> This rule enforces spacing around the * in yield* expressions. To use this rule you either need to use the es6 environment or set ecmaVersion to 6 in parserOptions.</Description>
                <HelpText>&lt;p&gt;This rule enforces spacing around the * in yield* expressions. To use this rule you either need to use the es6 environment or set ecmaVersion to 6 in parserOptions.&lt;/p&gt;</HelpText>
            </Language>
            <Baselines />
            <Settings>
                <Setting name="Priority" editable="true">Major</Setting>
                <Setting name="__eslint_param__" editable="true">{"before": true, "after": false}</Setting>
            </Settings>
            <Calculated />
        </Configuration>
    </Metric>
<!-- ============================== -->
<!-- ECMAScript6 END                -->
<!-- ============================== -->

 </Rul>